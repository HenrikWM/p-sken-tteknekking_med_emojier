<!DOCTYPE html>
<html lang="nb">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <title>Påskenøttknekking med emojier 🐇 - JavaZone 2023</title>

    <meta
      name="description"
      content="Påskenøttknekking med emojier 🐇 - JavaZone 2023"
    />
    <meta name="author" content="Henrik Walker Moe" />

    <meta
      name="viewport"
      content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <meta
      property="og:title"
      content="Påskenøttknekking med emojier 🐇 - JavaZone 2023"
    />
    <meta
      property="og:description"
      content="En gjennomgang av oppgaven 'Andre påskedag' fra PSTs påske-CTF 2020"
    />
    <meta property="og:site_name" content="Github" />
    <meta
      property="og:image"
      content="https://henrikwm.github.io/p-sken-tteknekking_med_emojier/img/paskekyllingbetjenter.png"
    />
    <meta property="og:type" content="article" />
    <meta
      property="og:url"
      content="https://henrikwm.github.io/p-sken-tteknekking_med_emojier"
    />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@github" />
    <meta name="twitter:creator" content="@henrikwm" />
    <meta
      name="twitter:title"
      content="Påskenøttknekking med emojier 🐇 - JavaZone 2023"
    />
    <meta
      name="twitter:description"
      content="En gjennomgang av oppgaven 'Andre påskedag' fra PSTs påske-CTF 2020"
    />
    <meta
      name="twitter:image"
      content="https://henrikwm.github.io/p-sken-tteknekking_med_emojier/img/paskekyllingbetjenter.png"
    />

    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="msapplication-tap-highlight" content="no" />

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/black.css" id="theme" />
    <link rel="stylesheet" href="dist/custom.css" />

    <!-- Theme used for syntax highlighted code -->
    <link
      rel="stylesheet"
      href="plugin/highlight/zenburn.css"
      id="highlight-theme"
    />

    <!-- Title-Footer plugin -->
    <link rel="stylesheet" href="plugin/title-footer/title-footer.css" />
    <link rel="stylesheet" href="plugin/title-footer/title-footer-custom.css" />

    <!-- Globals -->
    <script type="text/javascript">
      var defaultFooterText =
        "Påskenøttknekking med emojier 🐇 - JavaZone 2023";
    </script>

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement("link");
      link.rel = "stylesheet";
      link.type = "text/css";
      link.href = window.location.search.match(/print-pdf/gi)
        ? "css/print/pdf.css"
        : "css/print/paper.css";
      document.getElementsByTagName("head")[0].appendChild(link);
    </script>

    <!-- QR Codes -->
    <script type="text/javascript" src="lib/qrcode.min.js"></script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- =================== START =================== -->
        <section>
          <section data-source="background_image">
            <p>
              <span class="fragment">henrikwm</span>
              <span class="fragment">@</span>
              <span class="fragment">bekk</span>
            </p>

            <aside class="notes">
              Heisann alle sammen! Og takk for at dere kom for å høre på meg
              idag! Setter stor pris på at så mange av dere stiller opp på
              dagens siste foredrag!<br /><br />

              Fordi det er siste foredrag: hvis det er noen som har noen
              <b>spørsmål underveis</b>, så kom gjerne opp til meg etterpå slik
              at vi <b>runder av i god tid</b><br /><br />

              Så len dere tilbake, senke skuldrene. La oss ha det litt gøy.<br /><br />

              Hvem er jeg? (NESTE)<br /><br />

              Mitt navn er Henrik Walker Moe og jeg jobber i (NESTE) (NESTE)<br />
              Bekk.<br /><br />
              Og idag skal jeg snakke om...
            </aside>
          </section>

          <section data-transition="concave" data-source="bitmoji">
            <div>
              <h2>Påskenøttknekking med emojier 🐇</h2>
              <img src="img/intro_spy_avatar.png" class="plain" />
            </div>

            <aside class="notes">
              <b>Påskenøttknekking med emojier!</b><br /><br />

              * Idag skal vi sammen løse en oppgave jeg koste meg med fra
              påskenøttene til Politiets Sikkerhetstjeneste (PST) fra 2020.<br /><br />

              * PST har i de siste årene lagt ut en Capture The Flag (CTF)
              konkurranse i påsken. En CTF-oppgave handler om å løse flere
              deloppgaver til man til slutt finner en skjult kode, også kalt et
              "flagg"<br /><br />

              * Når man sender inn riktig flagg får man poeng. Den mest flest
              poeng innen konkurransens slutt vinner.<br /><br />
            </aside>
          </section>
        </section>

        <!-- =================== OM MEG ========================================= -->
        <section>
          <section>
            <h2>Hvem er jeg?</h2>

            <aside class="notes">Et par ord om meg</aside>
          </section>

          <section
            data-background="img/intro_henrik_ecotrail.JPG"
            data-source="henrikwm"
          >
            <aside class="notes">
              Jeg...<br />
              * liker å løpet<br />
              * er sta, har pågangsmot <br />
              * liker utfordringer med klare mål<br /><br />

              * Sikkerhet er et fagfelt jeg har brukt mye tid i. Både som
              fagleder for sikkerhetsfaggruppen vår og i vår satsning på
              sikkerhet i Bekk<br /><br />

              (ANEKDOTE):<br />
              Appropos sikkerhet og JavaZone: hyggelig å være tilbake på
              JavaZone! Jeg har tidligere snakket om sømløse
              innloggingsløsninger, mitt personvernsbidrag til Smittestopp 2 og
              kodeknekking for spioner<br /><br />

              Så sikkerhet og kodeknekking er min greie, kan du si.<br /><br />
            </aside>
          </section>

          <section>
            <h3>I ❤️ CTF-er</h3>

            <aside class="notes">
              Og som nevnt, jeg digger CTF-oppgaver!<br /><br />

              * Hvorfor liker jeg CTF'er? <br />
              ** <b>Prosessen</b>: <b>rekognosering</b> og <b>analyse</b> for å
              forstå hvordan man kan <b>utnytte</b> en sårbarhet eller knekke en
              kode for å finne flagget<br />
              ** <b>Måldrevne</b>: delmål underveis, motiverer<br />
              ** <b>Belønning!</b>: (flagget, viktig spisskompetanse)<br /><br />

              På mange måter er CTF-konkurranser sikkerhetsbransjens e-sport.
              For min del gjør det kompetansebygging både gøy og motiverende når
              jeg vet at neste mestringsfølelse er <b>ett flagg</b> unna.
            </aside>
          </section>

          <!--<section>
            <h3>Sikkerhetsfaggruppen ❤️ CTF-er</h3>
            <aside class="notes">
              Vi i Sikkerhetsfaggruppen i Bekk bruker CTF'er aktivt til
              kompetansebygging. Både fordi CTF'er ofte er pedagogisk bra lagt
              opp men også fordi de er så motiverende å jobbe med når du endelig
              finner det flagget du har slitt lenge med å finne!<br /><br />

              Idag skal vi sammen kjenne litt på den gleden.
            </aside>
          </section>-->
        </section>

        <!-- =================== OPPGAVEN ======================================= -->
        <section>
          <section>
            <h2>"Andre påskedag"</h2>

            <aside class="notes">
              Oppgaven jeg skal ta dere igjennom idag heter
              <b>Andre påskedag</b> <br /><br />

              Grunnen til at jeg ønsker å vise dere akkurat denne oppgaven er
              fordi ikke bare var den morsom, den utfordrer deg også på viktige
              egenskaper man trenger som problemløser og kodeknekker:<br /><br />

              * analytisk <br />
              * bryte ned problemet<br />
              * kunne verktøyene<br />
              * forstå fagteorien bak problemstillingen man må løse<br /><br />

              Så er det jo også en haug med emojis her som jo er litt spennende!
            </aside>
          </section>

          <section>
            <h3>Vi har fått 3 filer</h3>
            <ul>
              <li>
                <a
                  href="ctf.phst.no/andre_påskedag/img/paskekyllingbetjenter.png"
                  >paskekyllingbetjenter.png</a
                >
              </li>
              <li>
                <a href="ctf.phst.no/andre_påskedag/merkelig.py">merkelig.py</a>
              </li>
              <li>
                <a href="ctf.phst.no/andre_påskedag/underfundig">underfundig</a>
              </li>
            </ul>

            <aside class="notes">
              Oppgaven gir oss disse 3 filene:<br /><br />

              * <b>påskekyllingbetjenter.png</b> (bilde)<br />
              * <b>merkelig.py</b> (Python-program)<br />
              * <b>underfundig</b> (fil med emojier)<br /><br />

              Det første vi må gjøre er å analysere det vi har fått og prøve å
              forstå problemstillingen.
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h2>Analyse</h2>
          </section>

          <section>
            <h3>paskekyllingbetjenter.png</h3>
            <img
              data-src="img/paskekyllingbetjenter.png"
              class="plain"
              style="width: 90%"
            />

            <aside class="notes">
              Vi begynner med bildet av påskekyllingbetjentene.<br /><br />

              For å lete etter ledetråder i bilder liker jeg å bruke
              Linux-programmene
              <b>file</b> og <b>strings</b>. Ofte finner man skjult tekst i
              bilder og filer i slike CTF'er, og disse programmene hjelper oss å
              finne dette.
            </aside>
          </section>

          <section>
            <p>
              Analyse med <span class="fragment highlight-green">file</span>:
            </p>
            <pre
              class="fragment fade-up"
            ><code class="python smaller" data-trim data-noescape>
            $ file paskekyllingbetjenter.png

            paskekyllingbetjenter.png: PNG image data, 1920 x 1080, \
            8-bit/color RGBA, non-interlaced
            </code>
            </pre>

            <aside class="notes">
              Jeg starter opp en Linux-terminal i Windows og prøver først med
              programmet <b>file</b> og gir den bildet vårt (NESTE):<br /><br />

              * Hva gjør <b>file</b> (NESTE)?<br /><br />

              Her får vi bekreftet at vi har et PNG-bilde. Ikke noe mer
              spennende enn det.
            </aside>
          </section>

          <section>
            <p>
              Analyse med <span class="fragment highlight-green">strings</span>:
            </p>
            <pre
              class="fragment fade-up"
            ><code class="python smaller" data-trim data-noescape>
            $ strings paskekyllingbetjenter.png

            ...
            PQ8I9C]
            =g+m*o)
            y|u?
            Io>rw
            K_rA
            l]@?
            %@X@
            rX#s
            2hf
            ...
            </code>
            </pre>

            <aside class="notes">
              Vi prøver med <b>strings</b> (NESTE):<br /><br />

              * Hva gjør <b>strings</b>? (NESTE) <br /><br />

              * Her ser vi bare masse tulletekst som egentlig er bildedata, og
              det er det. Ikke noe flagg gjemt her heller<br /><br />

              Da må vi innom en tredje analyseteknikk:
              <b>Steganografi</b>-analyse!
            </aside>
          </section>

          <section>
            <p>
              Steganografi-analyse:
              <a
                href="https://github.com/eugenekolo/sec-tools/raw/master/stego/stegsolve/stegsolve/stegsolve.jar"
                >Stegsolve.jar</a
              >
            </p>
            <pre>
              <code data-trim class="python">$ java -jar stegsolve.jar</code>
            </pre>

            <aside class="notes">
              Å skjule data i et bilde kalles <b>Steganografi</b><br /><br />

              * Stegsolve: et Java-program som lar oss kikke igjennom
              fargefiltre i bildet<br />
              ** ser etter <b>skjult tekst</b> eller <b>andre skjulte bilder</b
              ><br /><br />

              La oss starte opp Stegsolve og først kikke på et
              <b>eksempel</b> på hvordan man kan finne en skjult kode i et bilde
            </aside>
          </section>

          <section
            data-transition="fade-in"
            data-source="failOverflow_doge_stege"
          >
            <img
              data-src="img/failOverflow_doge_stege.png"
              class="plain"
              style="width: 70%"
            />

            <aside class="notes">
              Her har jeg funnet fram et bilde fra en annen CTF-oppgave
              <b>doge_stege</b> (<b>Plaid CTF 2014</b>)<br /><br />

              Vi klikker igjennom fargefiltrene i Stegsolve...
            </aside>
          </section>

          <section
            data-transition="none fade-out"
            data-source="failOverflow_doge_stege"
          >
            <img
              data-src="img/insignificant_shark-doge-decoded-highlighted.png"
              class="plain"
              style="width: 70%"
            />

            <aside class="notes">
              Se der!<br /><br />

              I et av fargefiltrene er koden (flagget) man skal finne gjemt:
              <b>pctf{keep_doge_alive_2014}</b><br /><br />

              Vi får se om det skjuler seg noe lignende hos
              påskekyllingbetjentene
            </aside>
          </section>

          <section data-source="stegsolve_caesum">
            <img
              data-src="img/paskekyllingbetjenter_stegsolve.gif"
              class="plain"
              style="width: 100%"
            />

            <aside class="notes">
              Nå har jeg lastet inn bildet av påskekyllingbetjentene i
              Stegsolve, og klikker igjennom fargefiltrene<br /><br />

              (VENTE 10s)<br /><br />

              Men vi finner ingenting her heller<br /><br />

              Konklusjon: bildet er bare lokkemat og vi legger bildet til side.
              Vi tar istedet en kikk på denne <b>underfundig</b>-filen
            </aside>
          </section>

          <section>
            <h3>underfundig</h3>
            <img
              data-src="img/underfundig_emojis.png"
              class="plain"
              style="width: 110%"
            />

            <aside class="notes">
              Dette var fil nummer to vi fikk. I <b>underfundig</b>-filen har vi
              1043 emojier på rad og rekke! (stablet de sammen her)<br /><br />

              Tydeligvis noe mening med dette. Vi ser noen emojier repeteres,
              noen bare forekommer en gang. Hva kan det være vi ser her?<br /><br />

              Ellers er ikke så mye mer å finne ut her på dette tidspunktet, så
              går videre til siste fil
            </aside>
          </section>

          <section>
            <h3>merkelig.py</h3>

            <p>Vi kjører programmet:</p>

            <pre class="shell">
              <span>$ python merkelig.py underfundig</span>              
              <span class="fragment">Passord: <span class="fragment highlight-green">123456</span></span>
              <span class="fragment">Ikke riktig :(</span>                
            </pre>

            <p class="fragment fade-up">🥺</p>

            <aside class="notes">
              Siste fil er <b>merkelig.py</b>. Det er et Python-program og
              programmet tar inn <b>underfundig</b>-filen som input. Når vi
              prøver å kjøre det (NESTE) så spør den etter et <b>passord</b
              ><br /><br />

              Vi får skrive noe og se hva som skjer. Prøver
              <b>123456</b> (NESTE)<br /><br />

              Programmet sier (NESTE) at passordet ikke er riktig (NESTE).<br /><br />

              Her kan vi lage et hjelpeprogram som bare gjetter seg frem, såkalt
              brute-force metoden, som er helt riktig måte å løse oppgaven på.
              Men hvorfor gå for den enkle løsningen?
            </aside>
          </section>

          <section>
            <p>Vi må finne passordet!</p>

            <aside class="notes">
              Så! Problemstillingen her er klar: finn passordet<br /><br />

              Siden bildet med påskekyllingbetjentene bare var lokkemat, og
              <b>underfundig</b>-filen bare en er haug med emojier, så må vi se
              nærmere på Python-programmet <b>merkelig.py</b>
            </aside>
          </section>

          <section data-transition="fade-in">
            <h3>merkelig.py</h3>
            <img
              data-src="img/merkelig_py_1.png"
              class="plain"
              style="width: 70%"
            />

            <aside class="notes">
              Hva kan vi tolke fra kildekoden vi ser her?
            </aside>
          </section>

          <section data-transition="none fade-out">
            <h3>merkelig.py</h3>
            <img
              data-src="img/merkelig_py_1_highlighted.png"
              class="plain"
              style="width: 70%"
            />

            <aside class="notes">
              * Vi ser enkelte emojier defineres med en tall-verdi (terning,
              sjokoladeplate, kontroller, hodetelefoner, palett og sukkertøy)
              <br />

              * Vi ser en funksjon <b>parse_num</b> som omgjør sin input til et
              tall<br />

              * Vi ser at <b>underfundig</b>-filen kreves som input for å kjøre
              programmet<br />

              * Vi ser en variabel <b>STACK</b> bli definert som et 256-plasser
              stort register<br />

              * Og vi legger merke til de andre variabelnavnene: <b>PC</b> og
              <b>SP</b>. Navnene er store hint.
            </aside>
          </section>

          <section data-transition="fade-in">
            <h3>merkelig.py</h3>
            <img
              data-src="img/merkelig_py_2.png"
              class="plain"
              style="width: 70%"
            />

            <aside class="notes">
              Videre ned i programmet ser vi en while-løkke. Noe skal repeteres
              flere ganger
            </aside>
          </section>

          <section data-transition="none fade-out">
            <h3>merkelig.py</h3>
            <img
              data-src="img/merkelig_py_2_highlighted.png"
              class="plain"
              style="width: 70%"
            />

            <aside class="notes">
              Når vi ser hva <b>OP</b>,<b>PC</b>,<b>STACK</b> og
              <b>SP</b> brukes til i hver runde i while-løkken, så begynner det
              å bli klart hva vi har med å gjøre her
            </aside>
          </section>
        </section>

        <!-- =================== STACK-BASERT VIRTUELL MASKIN =================== -->
        <section>
          <section>
            <h2>Stack-basert virtuell maskin</h2>

            <aside class="notes">
              Det vi har her er en
              <b>Stack-basert virtuell maskin</b>!<br /><br />

              Da jeg fikk vite jeg fikk siste tidsluke på siste dag av JavaZone,
              tenkte jeg: her vil sikkert folk allerede har hodet fullt. Er det
              ikke
              <b>litt ambisiøst</b> å prøve å forklare hvordan datamaskiner
              kjører programmer og hva en stack-basert virtuell maskin er?<br /><br />

              Men jeg tar utfordringen - dette er ikke bare fjasing med emojier.
              Til og med her skal dere <b>få litt faglig utbytte</b>!
            </aside>
          </section>

          <section data-source="stack_machine">
            <p>Fra Wikipedia:</p>
            <blockquote>
              A "stack machine" is a computer that uses a last-in, first-out
              stack to hold short-lived temporary values. Most of its
              instructions assume that operands will be from the stack, and
              results placed in the stack.
            </blockquote>

            <aside class="notes">
              Python-programmet <b>merkelig.py</b> er vår virtuelle maskin og
              <b>underfundig</b>-filen med emojiene er <b>programmet</b> den
              kjører<br /><br />

              Her har noen altså kompilert et program til å kjøre på den
              virtuelle maskinen og "maskinkoden" med data og instruksjoner er
              emojiene i
              <b>underfundig</b>-filen
            </aside>
          </section>

          <section>
            <p>Hva kjennetegner en stack-basert virtuell maskin?</p>
            <ul class="fragment">
              <li>
                <span class="fragment highlight-green">stack</span>: register
                med programmets data
              </li>
              <li>
                <span class="fragment highlight-green">sp</span>: stack pointer
                peker på minneadressen som inneholder neste posisjon (toppen) av
                stacken
              </li>
              <li>
                <span class="fragment highlight-green">pc</span>: program
                counter (programteller) vet i hvilken minneadresse den finner
                neste instruks/data
              </li>
              <li>
                <span class="fragment highlight-green">op</span>: operand
                (<b>pop</b>, <b>push</b>, <b>jmp</b>, <b>xor</b> osv.)
              </li>
            </ul>

            <aside class="notes">
              Hva kjennetegner en stack-basert virtuell maskin: (NESTE x2)<br /><br />

              * STACKen er minneregisteret hos den virtuelle maskinen som tar
              vare på programmets data og instruksjoner når programmet kjører.
              Som vi så tidligere har denne virtuelle maskinen 256 minneadresser
              (NESTE)<br /><br />

              * SP (stack-pointer) peker på minneadressen til toppen av stacken
              (NESTE)<br /><br />

              * PC (program counter) er programtelleren, også kalt
              instruksjonspeker, som holder styr på rekkefølgen av instruksjoner
              som kjøres. Den vet i hvilken minneadresse på stacken programmet
              skal finne neste data eller instruksjon (NESTE)<br /><br />

              * OP er operanden (instruksjonen) som programmet ønsker at
              maskinens hjerne (gjerne CPU-en i en datamaskin) skal utføre for
              oss.<br />
              Push legger til data på stacken og Pop leser ut data fra
              stacken.<br />
              Jmp forteller programmet at det skal hoppe til et sted i
              minnet.<br />
              XOR er en av flere vanlige binæroperasjoner man kan gjøre på data
              (man har ofte i tillegg AND, OR osv.)
            </aside>
          </section>

          <section data-source="wiki_callstack">
            <img
              data-src="img/call_stack_layout.svg.png"
              class="plain"
              style="width: 70%"
            />

            <aside class="notes">
              Vi kan godt se for oss en mental modell av en STACK slik. Her med
              et eksempel som et grafikkprogram og den har to subrutiner
              "DrawLine" og "DrawSquare".<br /><br />

              Hver av disse subrutinene har plassert sine data i minneadressene
              på maskinens STACK.<br /><br />

              Se for deg her en datamaskin med flere gigabytes med minne og
              mange programmer som kjører samtidig. Stack pointer og program
              counter holder styr på hvor neste data og instrukser er slik at
              det ikke blir helt kaos.<br /><br />

              ANEKDOTE 1: Hvis programmer gjør noe galt og fyller opp hele
              stacken (typisk hvis man lager en evig loop ved et uhell), da får
              man StackOverflow-feil. StackOverflow.com er jo en nettside noen
              her kanskje sikkert kjenner til...<br /><br />

              ANEKDOTE 2: Noen tenker kanskje at hvis man klarer å manipulere
              disse minneadressene og få et program til å lese annen data, eller
              peke til et annet sted i minne hvor du vil at den istedet skal
              lete, så er det nyttig manipulasjon å kunne.<br />
              Og det er helt riktig. Slik hacking gjør at man f.eks. kan cracke
              programmer og lese hemmeligheter fra minnet på datamaskinen.
            </aside>
          </section>

          <section>
            <p>
              Alle operand-emojiene <b>underfundig</b> inneholder:<br />
              <br />
              🐰🐥🌱🌻🐇🥚🐤🐣🌞
              <br />
            </p>
            <p class="fragment">
              er
              <span class="fragment highlight-green">maskininstruksjoner</span>!
            </p>

            <aside class="notes">
              Så nå vet vi litt mer om STACKen og hvordan programmet kjører, så
              vi går videre med emojiene våre.<br /><br />

              Vi vet nå at alle operandene vi ser i <b>underfundig</b>-filen er
              (NESTE x2)...<br /><br />
              <b>maskininstruksjoner</b> til et program som kjører på denne
              virtuelle maskinen!
            </aside>
          </section>

          <section>
            <pre
              class="even-less-spacing"
            ><code class="python smallester" data-trim data-noescape>
              (...)
              elif op == "🐥": # 1. kylling tilsvarer assembly-instruksjonen "PUSH"
                  stack[sp] = stack[sp-1]
                  sp += 1
              elif op == "🌱": # 2. frø tilsvarer assembly-instruksjonen "ADD"
                  sp -= 1
                  stack[sp-1] += stack[sp]
                  stack[sp-1] %= base**4
              elif op == "🌻": # 3. solsikke tilsvarer assembly-instruksjonen "SUB"
                  sp -= 1
                  stack[sp-1] -= stack[sp]
                  stack[sp-1] %= base**4
              elif op == "🐇": # 4. kanin tilsvarer assembly-instruksjonen "JMP"
                  sp -= 1
                  if stack[sp] != 0:
                      pc += parse_num(code[pc:pc+4])
                  else:
                      pc += 4
              (...)
            </code></pre>

            <aside class="notes">
              Vi kjenner igjen mange av disse operandene i den virtuelle
              maskinen. Flere ligner litt på kjente instruksjoner fra
              assembly-språk (det språket CPU'en, hjernen i datamaskinen,
              forstår):<br /><br />

              * Pkt.1: <b>kylling</b> flytter gjeldende stack-verdi i stacken en
              plass ned i stack-registeret, altså "push"<br />
              * Pkt.2: <b>spire</b> gjør blant annet addering mellom to
              stack-verdier, altså "add"<br />
              * Pkt.3: <b>solsikke</b> gjør blant annet subtraksjon mellom to
              stack-verdier, altså "sub"<br />
              * Pkt.4: ...og <b>kaninen</b> hopper til ny instruksjon eller
              videre i programmet, altså "jump"<br /><br />

              Så når vi sammenligner alle operandene i denne virtuelle maskinen
              med noe som ligner LITT på mer kjente maskininstruksjoner som
              CPU'ene i våre datamaskiner forstår...
            </aside>
          </section>

          <section>
            <p>Operander og maskininstrukser i den virtuelle maskinen:</p>
            <table>
              <thead>
                <tr>
                  <th>Emoji-operand</th>
                  <th>Tilsvarer instruksjon</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>🐇</td>
                  <td>jmp</td>
                </tr>
                <tr>
                  <td>🐥</td>
                  <td>push</td>
                </tr>
                <tr>
                  <td>🌻</td>
                  <td>pop_sub</td>
                </tr>
                <tr>
                  <td>🌱</td>
                  <td>pop_add</td>
                </tr>
                <tr>
                  <td>🥚</td>
                  <td>xor (⊕)</td>
                </tr>
                <tr>
                  <td>...</td>
                  <td>...</td>
                </tr>
              </tbody>
            </table>

            <aside class="notes">
              ...så får vi dette! Har man erfaring med assembly-språk og lavnivå
              programmering så kjenner man igjen hva alle disse operandene i vår
              virtuelle maskin tilsvarer:<br /><br />

              * operanden kanin "hopper" (jump)<br />
              * kylling er "push" <br />
              * solsikke er "pop" og "sub"<br />
              * spire er "pop" og "add"<br />
              * egg er XOR (en binærmatematikk som regner på to faktorer). XOR i
              CTF-er er gjerne brukt til enkel kryptering... interessant!
            </aside>
          </section>

          <section>
            <p>
              <b>underfundig</b> er et program som er
              <span class="fragment highlight-green">kompilert</span> til
              emojier
            </p>
            <br />
            <p class="fragment">
              kan vi <span class="fragment highlight-green">dekompilere</span>
              programmet tilbake til menneskelesbar kildekode?
            </p>

            <aside class="notes">
              Når man lager programmer så kompilerer (NESTE) man kildekoden med
              en kompilator, som omgjør menneskelesbar kildekode til lavnivå
              maskininstrukser som maskinen kan forstå og kjøre<br /><br />

              <b>underfundig</b>-filen kan man si er "kompilert" til emojier
              slik at den kan kjøres på denne virtuelle maskinen i
              <b>merkelig.py</b><br /><br />

              Hvis vi kan reversere (NESTE) det kompilerte programmet tilbake
              til menneskelesbar kildekode, dvs. dekompilere (NESTE) det, så kan
              vi kanskje forstå hva programmet gjør og finne det passordet vi er
              på jakt etter
            </aside>
          </section>
        </section>

        <!-- =================== DEKOMPILERING =================== -->
        <section>
          <section>
            <h2>Dekompilering</h2>
          </section>

          <section>
            <p>
              For å lage et dekompileringsprogram må vi forstå
              <b>underfundig</b> litt bedre
            </p>

            <aside class="notes">
              Vi lærte at <b>underfundig</b>-programmet inneholder operander,
              men for å dekompilere hele programmet må vi også vite hva resten
              av emojiene er
            </aside>
          </section>

          <section>
            <p>Finner vi et mønster i emojiene?</p>
            <div class="fragment fade-up">
              <p>🐰🎮🍫🎮🎲🐤🐰🍫🎨🎮🎲🐤🐰🍫🍫🎧🎲🐤</p>
              <p>-</p>
            </div>

            <div class="fragment fade-up">
              <p>🐰🐥🌱🌻🐇🥚🐤🐣🌞</p>
              <p>=</p>
            </div>

            <div class="fragment fade-up">
              <p>🎮🍫🎮🎲🍫🎨🎮🎲🍫🍫🎧🎲</p>
            </div>

            <aside class="notes">
              Kanskje kan vi finne et mønster i underfundig-emojiene? (NESTE)
              <br /><br />

              * Dette er de første emojiene i
              <b>underfundig</b>-filen...(NESTE)<br />

              * Hvis vi tar vekk de operand-emojiene som vi vet er
              maskininstruksjoner (NESTE)<br />

              * Hva sitter vi igjen med da?<br /><br />

              Kan dette være data, altså bokstaver og tall, som programmet
              bruker til noe?
            </aside>
          </section>

          <section>
            <p>
              Vi vet hva som er operander: <br />
              🐰🐥🌱🌻🐇🥚🐤🐣🌞
            </p>
            <br />
            <p>I <b>merkelig.py</b> så vi:</p>
            <pre><code class="python" data-trim data-noescape>
            digits = {"🎲": 0, "🍫": 1,  "🎮": 2, "🎧": 3, "🎨": 4, "🍬": 5}
            </code></pre>
            <br />
            <p>Så vi vet at disse er data: <br />🎲🍫🎮🎧🎨🍬</p>

            <aside class="notes">
              Siden vi nå vet hvilke emojier som er operander og hvilke som er
              data, så har vi det vi trenger for å dekompilere programmet
            </aside>
          </section>

          <section>
            <p>
              Vi lager et nytt Python-program
              <b>underfundig_dekompilering.py</b>:
            </p>
            <pre class="even-less-spacing">
              <code class="python" data-trim data-noescape>
              code = open(sys.argv[1], "rt", encoding="utf-8").read()

              write_decoded_commands(code) # code=innholdet i underfundig-filen
              </code>
            </pre>

            <p>Kjører programmet:</p>

            <pre>
              <code class="python" data-trim data-noescape>
              $ python underfundig_dekompilering.py underfundig
              </code>
            </pre>

            <p>som lager en ny fil: <b>underfundig_dekompilering_output</b></p>

            <aside class="notes">
              Vi lager oss hjelpeprogrammet
              <b>underfundig_dekompilering.py</b> som inneholder en funksjon
              <b>write_decoded_commands</b>: <br />

              * den funksjonen tar inn alt innholdet i <b>underfundig</b>-filen
              <br />
              * deretter oversetter den emojiene til operander og data<br />
              * og tilslutt skriver resultatet til en fil
              <b>underfundig_dekompilering_output</b><br /><br />

              Forhåpentligvis viser filen oss hva hver emoji egentlig gjør i den
              rekkefølgen som programmet kjører.<br /><br />

              Vi kjører hjelpeprogrammet i terminalen vår og i filen vår ser
              vi...
            </aside>
          </section>

          <section>
            <img
              data-src="img/underfundig_dekompilert.png"
              class="plain"
              style="width: 30%"
            />

            <aside class="notes">
              Dette! Linje for linje ser vi alle operandene og emoji-dataene som
              programmet består av: <br /><br />

              * Øverst på steg 0 i programmet: <b>Hare</b> leser inn de neste 4
              emojiene fra <b>STACK'en</b><br />

              * Under ser vi de 4 data-emojiene (tallverdi 80, 80 i
              ASCII-tabellen er bokstaven "P"). ASCII-tabellen er en liste over
              alle tegn på tastaturet ditt, hvor hver tegn har en tallverdi<br />

              * På steg 5 i programtelleren: <b>Kylling</b> skriver "P" ut til
              terminalen min <br /><br />

              Så vi klarer nå å lese at det første programmet gjør er å skrive
              ut "Passord:" til terminalen min, slik vi så det gjorde tidligere
              da jeg testet å kjøre <b>merkelig.py</b>
            </aside>
          </section>

          <section>
            <p>I <b>merkelig.py</b> så vi:</p>
            <pre><code class="python" data-trim data-noescape>
            if op == "🐰":
              stack[sp] = parse_num(code[pc:pc+4]) # les inn 4 emojier
              sp += 1
              pc += 4
            </code></pre>
            <p>🐰 leser 4 emojier av gangen og omgjør til et tall</p>

            <aside class="notes">
              Vi har forstått at <b>hare</b>-operanden i den virtuelle maskinen
              vår leser inn 4 tegn av gangen<br /><br />

              Og tilbake fra <b>parse_num</b>-funksjonen får vi et tall...<br /><br />

              Hva slags tall er disse 4 og 4 data-emojiene tro?
            </aside>
          </section>

          <section>
            <p>Data-emojiene ser ut til å være bokstaver!</p>
            <table>
              <tr>
                <td></td>
                <td>🎮🍫🎮🎲</td>
                <td>🍫🎨🎮🎲</td>
                <td>🍫🍫🎧🎲</td>
                <td>🍫🍫🎧🎲</td>
              </tr>
              <tr>
                <td>ASCII-tallverdi</td>
                <td>80</td>
                <td>97</td>
                <td>115</td>
                <td>115</td>
              </tr>
              <tr>
                <td>Bokstav</td>
                <td class="fragment highlight-green">P</td>
                <td class="fragment highlight-green">a</td>
                <td class="fragment highlight-green">s</td>
                <td class="fragment highlight-green">s</td>
              </tr>
            </table>

            <aside class="notes">
              Jo! Det viser seg at flere av data-emojiene i
              <b>underfundig</b>-programmet er tekst! Dekompileringen vi nettopp
              gjorde viste oss 4 og 4 av disse emojiene (NESTE x4)<br /><br />

              Her ser vi at de første data-emojiene gir oss "Pass", som vi antar
              er "Passord" (det programmet skrev ut da den ba oss om å skrive
              inn et passord istad)<br /><br />

              Kan vi lage et Python-program som skriver ut all den skjulte
              teksten i hele
              <b>underfundig</b>-programmet tro? Litt som når vi bruker
              programmet <b>strings</b> på Linux for å finne skjult tekst i
              filer, i grunn.
            </aside>
          </section>

          <section>
            <p>
              Vi lager et nytt program
              <b>løsning.py</b> som henter ut alle bokstaver i
              <b>underfundig</b>:
            </p>

            <pre>
              <code class="python" data-trim data-noescape>
              text = extract_text(underfundig_content)

              print(text)
              </code>
            </pre>

            <div class="fragment">
              <p>og kjører programmet:</p>
              <pre>
                <code class="python" data-trim data-noescape>
                $ python løsning.py underfundig
                </code>
              </pre>
            </div>

            <aside class="notes">
              Vi lager oss et nytt program som blir starten på løsningen:
              <b>løsning.py</b>: <br />

              * programmet inneholder en funksjon <b>extract_text</b> som
              oversetter alle data-emojiene til ASCII-tallverdier<br />

              * og så gjør den om disse ASCII-tallverdiene til ASCII-tegn slik
              at tallene blir til bokstaver og tegn vi kjenner igjen fra vårt
              tastatur (NESTE)<br /><br />

              Vi kjører programmet og gir den <b>underfundig</b>-filen som input
            </aside>
          </section>

          <section>
            <h3>
              <span class="fragment highlight-green">Passord:</span>
              <span class="fragment highlight-green">"</span
              ><span class="fragment highlight-green"
                >w*4*D*T*W*J*7*A*Y*f*`*j*n***}*4*\x9d*ç*¿*Ą*Ŏ*Ŋ*Ŧ*ı*Ɖ*Ǔ*Ǒ*Ǐ*ǐ*Ǉ*Ǧ*ǜ*ƹ*ț*ɵ</span
              ><span class="fragment highlight-green"
                >Gratulerer! Flagget vet du allerede :)\nIkke riktig :(\n</span
              >
            </h3>

            <aside class="notes">
              Og dette er det vi får. Spennende! Her ser vi all teksten som
              programmet inneholder!<br /><br />

              Vi kjenner igjen noe av teksten: (NESTE)<br />

              * 'Passord: ' er det programmet skriver ut til terminalen når den
              ber om passordet (NESTE)<br />

              * så har vi et hermetegn (NESTE)<br />

              * og så mange kryptiske tegn i ca. strukturert form (annenhver
              tegn og stjerne) (NESTE)<br />

              * Til slutt 'Gratulerer! Flagget vet du allerede smilefjes' og
              'Ikke riktig'. Som er teksten programmet gir oss ved galt eller
              riktig passord
              <br /><br />

              Vi vet at den teksten som vi kan lese her er det programmet selv
              skriver ut. Jeg er mye mer interessert i den
              <b>ikke-lesbare teksten her</b>. Jeg mistenker sterkt at dette er
              chifferteksten (dvs. det krypterte passordet) vi er ute etter!
            </aside>
          </section>

          <section>
            <p>w*4*D*T*W*J*7*A*Y*f*`*j*n***}*4*</p>
            <p>\x9d*ç*¿*Ą*Ŏ*Ŋ*Ŧ*ı*Ɖ*Ǔ*Ǒ*Ǐ*ǐ*Ǉ*Ǧ*ǜ*ƹ*ț*ɵ</p>
            <br />
            <h3 class="fragment fade-up">🕵️‍♀️🕵️‍♂️</h3>

            <aside class="notes">
              Så dette er chifferteksten vi må dekryptere og vår neste
              utfordring (NESTE)<br /><br />

              Vi trenger å forstå hvordan chifferteksten har blitt kryptert slik
              at vi kan dekryptere den. Da er jeg rimelig sikker på at vi har
              passordet og flagget vårt
            </aside>
          </section>
        </section>

        <!-- =================== DEKRYPTERING =================== -->
        <section>
          <section>
            <h2>Dekryptering</h2>
          </section>

          <section>
            <p>
              Målet vårt nå er å dekryptere chifferteksten til noe som ligner
              flaggformatet <b class="fragment highlight-green">PHST{...}</b>
            </p>

            <aside class="notes">
              Målet vårt nå er å se om vi kan dekryptere chifferteksten til noe
              som ligner flaggformatet som CTF-oppgaven forventer (NESTE):<br /><br />

              PHST{...} (påskeharens sikkerhetstjeneste med passordet imellom
              krøllparantesene)
            </aside>
          </section>

          <section>
            <p>
              Vi endrer litt på <b>merkelig.py</b>: <br />skriv ut hele stacken
              for hver operand-instruksjon som blir utført
            </p>
            <pre><code class="python" data-trim data-noescape>
            $ python merkelig.py underfundig
            Passord: tulleinput
            </code></pre>

            <aside class="notes">
              Jeg er interessert i XOR-operanden (egg-emojien) vi så
              <b>underfundig</b>-programmet brukte tidligere. Jeg mistenker den
              brukes til kryptering men jeg må ha full oversikt over alt som
              skjer og dataverdier i stacken, når <b>underfundig</b>-programmet
              kjøres, for å forstå nøyaktig hva som skjer<br /><br />

              Så vi tilpasser <b>merkelig.py</b> slik at vi ser det samme som
              maskinen ser når <b>underfundig</b>-programmet kjøres. Dette er
              vanlige verktøy vi utviklere bruker i hverdagen, her bygger jeg et
              slikt verktøy selv. Vi ønsker å se hva vi har "på stacken" når
              programmet kjører.<br /><br />

              Vi kjører <b>merkelig.py</b> igjen, gir passordet "tulleinput",
              slik at vår oversikt over innholdet i stacken kan genereres
            </aside>
          </section>

          <section>
            <pre class="shell bigger">
              <pre class="" data-trim data-noescape>
              (...) t , u , l , l , e , i , n , p , u , t
              🐣:116,117,108,108,101,105,110,112,117,116,(10) (...)
              🐣:116,117,108,108,101,105,110,112,117,116,10,(0) (...)
              🐰:116,117,108,108,101,105,110,112,117,116,10,(34) (...)
              🐰:116,117,108,108,101,105,110,112,117,116,10,34,(0) (...)
              🌻:116,117,108,108,101,105,110,112,117,116,10,(34) (...)
              🌻:116,117,108,108,101,105,110,112,117,116,<mark>-24</mark>,(34) (...) 
              🌻:116,117,108,108,101,105,110,112,117,116,<mark>1272</mark>,(34) (...) 
              🐇:116,117,108,108,101,105,110,112,117,116,(1272),34 (...) 
              🐰:116,117,108,108,101,105,110,112,117,116,<mark>(73)</mark>,34 (...) 
              (...)
              </pre>
            </pre>
            <p>
              <b>tulleinput</b> gir et negativt tallverdi på stacken som gjør at
              programmet alltid hopper til "Ikke riktig :("
            </p>

            <aside class="notes">
              Her er stacken, et register med 256-minneplasser, skrevet ut
              bortover mot høyre med 256 plasser med data. Stacken er en "Last
              in, first out"-stack som betyr at plassen som er lengst mot høyre
              er dataverdien som er sist lagt på stacken<br /><br />

              Hver linje er den rekkefølgen instruksene har kjørt, gjerne kalt
              en kall-stack av oss utviklere.<br /><br />

              Vi ser at <b>underfundig</b>-programmet har lest inn passordet
              vårt <b>tulleinput</b> inn på stacken som ASCII-tallverdier<br /><br />

              Det vi kan tolke her er at <b>tulleinput</b> stadig vekk er feil
              passord. Etter passordet vårt ser vi 34 og så et negativt tall
              (-24), og kaninen ber programmet hoppe til 1272, som er starten på
              "Ikke riktig :("-feilmeldingen (ASCII-tallet 73 er "I"). Stacken
              videre nedover viser at programmet skriver ut denne beskjeden til
              min terminal
            </aside>
          </section>

          <section>
            <p>
              Etter mange forsøk ulike passord med ulike lengder, og observasjon
              av forandringer i stacken...
            </p>
            <p class="fragment">Hvis passordet er 34 tegn langt...</p>

            <aside class="notes">
              Etter mye prøving av flere passord og observasjon av stacken...<br />

              så jeg at tallet 34 forekom ofte på toppen av stacken etter at
              passordet var lest inn (NESTE)<br /><br />

              og da jeg testet et passord som var 34 tegn langt...
            </aside>
          </section>

          <section>
            <p>Passord <b>tulleinput123456789123456789123456</b> gir:</p>
            <pre class="shell bigger">
              <pre class="" data-trim data-noescape>
              (...)     9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6
              🌻:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,0,(<mark>34</mark>) (...)
              🐇:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,<mark>(0)</mark>,34 (...)
              🐰:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,(119),34 (...)
              🐰:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,119,(34) (...)
              🥚:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,(119),34 (...)
              🥚:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,65,(119),34 (...)
              🐰:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,65,(42),34 (...)
              🐰:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,65,42,(34) (...)
              (...)
              </pre>
            </pre>

            <p class="fragment">
              Programmet kjørte litt lenger nå, vi har kommet til 🥚 (⊕)
            </p>

            <aside class="notes">
              så er 34 der igjen, men noe mer har skjedd (NESTE)<br /><br />

              Programmet kjørte visst <b>videre</b> til nye instrukser nå og vi
              ser egget (XOR) blir brukt! XOR som vi istad snakket om ofte blir
              brukt til kryptering.
            </aside>
          </section>

          <section>
            <p>
              ASCII-tallet <b>34</b> er tegnet
              <span class="fragment highlight-green">"</span>
            </p>
            <p>
              I teksten vi fant i <b>underfundig</b>: <br />
              <span class="fragment highlight-green"
                >Passord: "w*4*D*T*W(...)</span
              ><br />
              ...finner vi tegnet
              <span class="fragment highlight-green"><b>"</b></span>
            </p>
            <p class="fragment">
              Vi har funnet programmets konstant for passordlengde! 😁
            </p>

            <aside class="notes">
              Tallet 34 (NESTE) i ASCII-tabellen er et "hermetegn"<br /><br />

              I den skjulte teksten i underfundig (NESTE) fant vi jo et
              hermetegn (NESTE x2)<br /><br />

              Vi ser ut til å ha funnet programmets konstant for passordlengde!
              Programmet gir alltid feilmelding hvis passordet vi gir ikke er 34
              tegn langt
            </aside>
          </section>

          <section>
            <p>Passord <b>tulleinput123456789123456789123456</b>:</p>
            <pre class="shell bigger">
              <pre data-trim data-noescape>
              (...)     9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6
              🌻:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,0,(34) (...)
              🐇:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,(<mark>0</mark>),34 (...)
              🐰:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,(119),34 (...)
              🐰:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,119,(34) (...)
              🥚:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,<mark>54,(119)</mark>,34 (...)
              🥚:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,<mark>65</mark>,(119),34 (...)
              🐰:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,65,(42),34 (...)
              🐰:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,65,42,(34) (...)
              (...)
              </pre>
            </pre>
            <p>
              Hvis gjeldende stack-verdi er "0" når 🐇 operanden kjøres, går den
              videre til XOR-operanden
            </p>
            <p class="fragment">119 ⊕ 54 = 65</p>

            <aside class="notes">
              Tilbake til det lange tullepassordet. Vi vet nå at passordets
              lengde skal være 34 tegn langt. Da kjører programmet videre og
              gjør XOR-operasjoner med innholdet på stacken, altså tegnene i
              passordet vårt<br /><br />

              Det viser seg at det er en sammenheng her: kanin-operanden har
              alltid tallverdi "0" som gjeldende stack-verdi når det senere
              XOR-es (NESTE)<br /><br />

              Her blir første tegn i chifferteksten ("w", <b>119</b>) XOR'et med
              siste tegn i tullepassordet jeg oppga ("6", <b>54</b>). Og svaret
              <b>65</b>
              puttes på stacken. Så krypteringsalgoritmen ligger foran oss her,
              hvis vi klarer å forstå faktorene som det XORes med
            </aside>
          </section>

          <section>
            <p>
              I <b>merkelig.py</b> hopper 🐇 alltid videre til
              feilmeldingsteksten hvis gjeldende verdi på stacken er forskjellig
              fra <b>0</b>:
            </p>
            <pre><code class="python smaller" data-trim data-noescape>
            elif op == "🐇":
            sp -= 1
            if stack[sp] != 0: # skal kaninen hoppe til ny instruks eller ikke?
                pc += parse_num(code[pc:pc+4]) # hopp til ny instruks (feilmelding)
            else:
                pc += 4 # programmet går videre til neste instruks
            </code></pre>
            <p class="fragment">
              Får vi gjeldende stack-verdi til å være <b>0</b> så kjører
              programmet videre til neste instruks istedet
            </p>

            <aside class="notes">
              Kaninen er nøkkelen for å komme videre. Hvis den er noe annet enn
              0, så hoppes det til ny instruks fra <b>underfundig</b>-programmet
              og programmet skriver ut "Ikke riktig"-feilmeldingen (NESTE)<br /><br />

              Men er gjeldende verdi på stacken når kaninen-operanden kjøres
              tallet null, så kjører programmet videre. Det er det ønsker vi å
              få til!
            </aside>
          </section>

          <section>
            <p>
              Ved å analysere stacken nærmere, kan vi regne oss fram til hva som
              skal til for at 🐇 operanden får <b>0</b> som gjeldende
              stack-verdi?
            </p>
            <pre
              class="less-spacing"
            ><code class="shell smallest" data-trim data-noescape>
            🥚:(...) 53,54,(119),34 (...) # 4. Hvis z er 10, så må 119 XOR 10 = 125 = }
            🥚:(...) 53,z,(119),34 (...)
            🐰:(...) 53,z,(42),34 (...)
            🐰:(...) 53,z,42,(34) (...)
            🌱:(...) 53,z,(42),34 (...) # 3. Her må z være 10, fordi 10 + 42 må bli 52
            🌱:(...) 53,y,(42),34 (...)
            🌱:(...) 53,y,(42),34 (...)
            🐥:(...) 53,107,(y),34 (...)
            🐥:(...) 53,107,y,(34) (...)
            🐰:(...) 53,107,y,(52) (...)
            🐰:(...) 53,107,y,52,(0) (...)
            🌻:(...) 53,107,y,(52) (...) # 2. Her må y være 52, fordi 52 - 52 må bli 0
            🌻:(...) 53,107,x,(52) (...)
            🌻:(...) 53,107,x,(52) (...)
            🐇:(...) 53,107,(x),52 (...) # 1. x skal være 0
            </code></pre>
            <p class="fragment">
              119 ⊕ (52-42) = <span class="fragment highlight-green">125</span>,
              dvs. ASCII-tegnet
              <span class="fragment highlight-green"><b>}</b></span> 😎
            </p>

            <aside class="notes">
              Hvordan skal vi sørge for at kaninen ikke hopper videre til
              feilmelding? På pkt. 1 nederst i stacken her må vi ha
              <b>0</b> som stack-verdi når kanin-operanden blir kjørt. Vi regner
              oss bakover fra stack-verdien hos kaninen og oppover i
              stack-verdiene. Jeg bruker x, y og z som variabler for å gjøre
              regnestykket enklere:<br />

              * Pkt 1. x må være 0<br />
              * Pkt 2. y må være 52 fordi her er operasjonen subtraksjon: 52
              minus 52 = 0.<br />
              * Pkt 3. z må være 10 fordi her er operasjonen addering: 10 + 42
              må bli 52<br />
              * Pkt 4. Hvis z er 10, så kan vi bruke XOR med 119 og 10 regne oss
              fram til det siste tegnet i det <b>ukrypterte</b> passordet
              (NESTE)<br /><br />

              119 XOR 10 = 125 (NESTE)(NESTE), ASCII-tallet 125 er ASCII-tegnet
              "krøllparantes".
            </aside>
          </section>

          <section>
            <h3>Algoritmen</h3>

            <p>kryptert tegn XOR (n+2 - n+1) = dekryptert tegn</p>

            <aside class="notes">
              Vi har her en algoritme, en fremgangsmåte som gir oss ett og ett
              dekryptert tegn fra chifferteksten:<br /><br />

              * ta første tegn i chifferteksten, XOR det med tegnet 2 plasser
              bort, minus tegnet 1 plass bort. Svaret er en ASCII-tallverdi som
              representerer vår første dekrypterte tegn!
            </aside>
          </section>

          <section>
            <p>
              <span class="fragment highlight-green">w</span
              >*4*D*T*W*J*7*A*Y*f*`*j (...)
            </p>

            <p class="fragment">w XOR (4-*)</p>

            <p class="fragment">
              ...med ASCII-tallverdier:<br />
              119 XOR (52-42) =
              <span class="fragment highlight-green">125</span>
              <br /><br />
              <b><span class="fragment highlight-green">}</span></b>
            </p>

            <aside class="notes">
              * Så fra chifferteksten vi har starter vi med "w" (NESTE)
              (NESTE)<br /><br />

              * w XOR med (4 minus "asteriks") (NESTE)<br /><br />

              * Dvs. med ASCII-tallverdier er w 119, 4 er 52 og asteriks er
              42.<br /><br />

              * Så 119 XOR med (52 minus 42), gir oss:<br /><br />

              125 (NESTE x2), som når vi slår opp i ASCII-tabellen er tegnet
              "høyre-krøllparentes"
            </aside>
          </section>

          <section>
            <p>
              w*<span class="fragment highlight-green">4</span
              >*D*T*W*J*7*A*Y*f*`*j (...)
            </p>

            <p class="fragment">4 XOR (D-*)</p>

            <p class="fragment">
              ...med ASCII-tallverdier:<br />
              52 XOR (68-42) =
              <span class="fragment highlight-green">46</span>
              <br /><br />
              <b><span class="fragment highlight-green">.</span></b>
            </p>

            <aside class="notes">
              Vi har første tegn i passordet! Vi prøver algoritmen på neste tegn
              i chifferteksten som er 4 (NESTE):<br /><br />

              * 4 XOR med (D minus "asteriks") (NESTE)<br /><br />

              * Dvs. med ASCII-tallverdier er 4 52, D er 68 og asteriks er
              42.<br /><br />

              * Så 52 XOR med (68 minus 42), gir oss:<br /><br />

              46 (NESTE x2), som når vi slår opp i ASCII-tabellen er tegnet
              "punktum"
            </aside>
          </section>

          <section>
            <p>
              Vi håndregner oss fram til vi har et par bokstaver i passordet:
            </p>
            <p class="fragment highlight-green"><b>}.nywG</b></p>
            <br />
            <h3 class="fragment fade-up">🤔</h3>

            <aside class="notes">
              Vi håndregner ut et par tegn til for å sjekke om algoritmen
              faktisk stemmer, og får: (NESTE)<br />

              * krøllparentes fra w-tegnet <br />
              * punktum fra 4-tegnet<br />
              * nywG (NESTE)<br /><br />

              Må innrømme at det ser litt gresk ut, hadde håpet på noe som
              lignet på passordet nå
            </aside>
          </section>

          <section>
            <p>
              Vi utvider
              <b>løsning.py</b> med ny funksjon som bruker algoritmen vår til å
              dekryptere resten av chifferteksten
            </p>

            <aside class="notes">
              Vi er på sporet av noe. Vi utvider programmet
              <b>løsning.py</b> med en ny funksjon som bruker denne algoritmen
              vi har funnet, og dekrypterer resten av chifferteksten for oss
            </aside>
          </section>

          <section>
            <p>
              Lager en decipher()-funksjon for å dekryptere chifferteksten i
              <b>løsning.py</b>:
            </p>

            <pre>
              <code class="python smaller" data-trim data-noescape>
                deciphered_cipher_raw = decipher(text) # text="Passord: "w*4*D*T*W (...)"

                print(deciphered_cipher_raw)
              </code>
            </pre>

            og kjører programmet:

            <pre>
              <code class="python" data-trim data-noescape>
                $ python løsning.py underfundig
              </code>
            </pre>

            <aside class="notes">
              Vi lager en <b>decipher</b>-funksjon i <b>løsning.py</b> for å
              hente ut det vi håper er dekrypterte flagget<br /><br />

              <b>dechipher</b>-funksjonen får chifferteksten som vi fant istad
              som input, og algoritmen vi har regnet oss frem til finner ett og
              ett passordtegn.<br /><br />

              Vi kjører <b>løsning.py</b> og krysser fingrene!
            </aside>
          </section>

          <section>
            <h3>}.nywG neP .nywG re nvan ttiM{TSHP</h3>

            <p class="fragment fade-up">😲</p>

            <aside class="notes">
              Vi er så nære! Men hva må vi gjøre her? (NESTE)<br /><br />

              Du ser at teksten her ikke er helt riktig.<br /><br />

              Stemmer, teksten er bakvendt! For å få riktig flaggformat så må
              reversere teksten
            </aside>
          </section>

          <section>
            <p>
              Vi snur om på rekkefølgen på den dechiffrerte teksten i
              <b>løsning.py</b>:
            </p>

            <pre>
              <code class="python" data-trim data-noescape>
              deciphered_cipher = deciphered_cipher_raw[::-1]

              print(deciphered_cipher)
              </code>
            </pre>

            og kjører programmet igjen:

            <pre>
              <code class="python" data-trim data-noescape>
              $ python løsning.py underfundig
              </code>
            </pre>

            <aside class="notes">
              Vi justerer <b>løsning.py</b> og snur om på rekkefølgen i den
              dekrypterte teksten<br /><br />

              Så kjører vi <b>løsning.py</b> igjen
            </aside>
          </section>
          <section>
            <h3>PHST{Mitt navn er Gwyn. Pen Gwyn.}</h3>

            <img
              data-src="img/penguin-dancing-moves.gif"
              class="fragment fade-up plain"
              style="width: 40%"
            />

            <aside class="notes">
              Yes! <b>Der</b> har vi endelig flagget! <br /><br />

              Mitt navn er Gwyn. Pen Gwyn. (NESTE) (vent 3s)
            </aside>
          </section>

          <section>
            <p>Vi kjører <b>merkelig.py</b> igjen:</p>
            <pre class="shell">
              <span>$ python merkelig.py underfundig</span>              
              <span class="fragment">Passord: <span class="fragment highlight-green">PHST{Mitt navn er Gwyn. Pen Gwyn.}</span></span>
              <span class="fragment">Gratulerer! Flagget vet du allerede :)</span>                
            </pre>

            <p class="fragment fade-up">😎</p>

            <aside class="notes">
              Da gjenstår det å verifisere at det faktisk ER passordet vi har
              funnet<br /><br />

              Vi kjører det opprinnelige programmet <b>merkelig.py</b> igjen og
              gir den det vi håper er passordet (NESTE) (NESTE)<br /><br />

              Og vi får bekreftet: (NESTE)
              <b>Gratulerer! Flagget vet du allerede :)</b> (NESTE)<br /><br />

              Kult!
            </aside>
          </section>

          <section data-source="leo_reversing">
            <img
              data-src="img/leo_reversing.jpg"
              class="plain"
              style="width: 60%"
            />

            <aside class="notes">
              Følelsen man har når man har kommet hit er ca slik! Vi i mål! Bra
              jobba for å holde ut helt hit. Jeg syns vi kan være litt stolte av
              å ha dekompilert et emoji-program som kjørte på en snedig variant
              av en stack-basert virtuell maskin skrevet i Python!<br /><br />

              Det var mye detektivarbeid for å komme helt hit men med litt
              pågangsmot, fokus, bruke tid på forstå ett og ett delproblem av
              gangen, og lage oss verktøy som gir litt bedre oversikt, så fant
              vi riktig løsning til slutt<br /><br />

              I CTF'er handler det ofte om å rekke å melde inn flaggene innen
              viss tid. Men jeg koste meg med dette. Brukte flere måneder i
              kalendertid når jeg hadde lyst på pirke videre på oppgaven. Lærte
              også masse om stack-baserte programmer underveis.
            </aside>
          </section>
        </section>

        <!-- =================== OPPSUMMERING =================== -->
        <section>
          <section>
            <h2>Gøy, ikke sant?</h2>

            <aside class="notes">
              Jeg håper denne oppgaven vekket litt nysgjerrighet hos dere slik
              som den gjorde for meg<br /><br />

              Syns du det du så idag så litt gøy ut?
            </aside>
          </section>

          <section>
            <h3>Tenn din indre kodegnist! 🪄</h3>
            <p>
              <a href="https://p26e.dev">p26e.dev fra PST</a>
            </p>
            <p>
              <a
                href="https://www.kode24.no/artikkel/hjelp-tom-a-bekjempe-tombot-i-porsverse---bli-med-i-kode24s-julekalender/74768986"
                >Kodekalender fra Kode24</a
              >
            </p>
            <p>
              <a href="https://www.youtube.com/@GynvaelEN/streams"
                >YouTube: Gynvael</a
              >
            </p>
            <p>
              <a href="https://ctf.hacker101.com">Hacker101 CTF</a>
            </p>
            <p>
              <a href="https://cryptohack.org">cryptohack.org</a>
            </p>

            <aside class="notes">
              Jeg håper dette tente din indre kodegnist. Vi blir bedre
              problemløsere av å øve.<br /><br />

              PST, Kode24 med flere pleier å legge ut CTF'er som adventskalender
              og påskenøtter.<br /><br />

              Lær ved å se andre løse oppgaver. Jeg har lært masser av
              <b>Gynvael</b> på YouTube!<br /><br />

              På CTF-sidene til Hacker101 finner du mange nybegynneroppgaver du
              kan starte med<br /><br />

              Hvis du synes XOR og binærmatematikk er spennende er
              cryptohack.org stedet for deg.<br /><br />

              Prøv deg på de enkle oppgavene. Kjenn litt på mestringsfølelsen
              når du begynner å finne flaggene. Jeg håper dere også blir hekta!
            </aside>
          </section>
        </section>

        <!-- =================== TAKK =================== -->
        <section data-transition="concave">
          <h2>Takk!</h2>
          <br />
          <div class="columns">
            <div class="col">
              <div
                class="qrcode"
                align="center"
                title="https://henrikwm.github.io/p-sken-tteknekking_med_emojier"
              ></div>
              <div class="half-size"><a class="qrcode-link"></a></div>
            </div>
            <div class="col">
              <img
                src="img/oppsummering-takk2.png"
                class="plain"
                style="width: 50%"
              />
            </div>
          </div>
          <br />
          <p>
            <a href="mailto:henrik.walker.moe@bekk.no"
              >henrik.walker.moe@bekk.no</a
            >
          </p>

          <aside class="notes">
            * Alt av det dere har sett idag om oppgaven og løsningen finner du
            på mitt GitHub-repo.<br /><br />

            * Tusen takk for at dere kom og hørte på!<br /><br />

            * Takk for meg!
          </aside>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>

    <!-- Reveal-listeners -->
    <script type="text/javascript" async defer>
      // Sources
      var sources = {
        background_image: "Foto: iStock.com, rami_hakala",
        bitmoji: "Bitmoji Avatar Ⓒ Snap Group Limited",
        henrikwm: "Kilde: Henrik Walker Moe, Lisens: CC BY 4.0",
        stegsolve_caesum: "Foto: StegSolve, Caesum, Windows 10",
        failOverflow_doge_stege:
          "Kilde: https://fail0verflow.com/blog/2014/plaidctf2014-for100-doge_stege/, Foto: jix, fail0verflow",
        leo_reversing: "Kilde: https://imgflip.com/i/4edng0",
        stack_machine: "Kilde: https://en.wikipedia.org/wiki/Stack_machine",
        wiki_callstack:
          "Kilde: https://commons.wikimedia.org/wiki/File:Call_stack_layout.svg",
      };

      function setFooterSource() {
        var currentSlide = Reveal.getCurrentSlide();

        var footer = document.getElementById("title-footer");
        if (footer) {
          footer.parentNode.removeChild(footer);
        }

        var source = currentSlide.getAttribute("data-source");
        if (source !== null) {
          title_footer.initialize(sources[source]);
        }
      }

      Reveal.addEventListener("ready", function (event) {
        setFooterSource();
      });

      Reveal.addEventListener(
        "slidechanged",
        function () {
          setFooterSource();
        },
        false
      );
    </script>

    <!-- QR Codes -->
    <script type="text/javascript">
      // Get presentation URL
      var qrcode_url =
        "https://henrikwm.github.io/p-sken-tteknekking_med_emojier";

      // Generate QR Codes : class="qrcode"
      var qrcode_elements = document.getElementsByClassName("qrcode");
      for (var i = 0; i < qrcode_elements.length; i++) {
        var qrcode_el = qrcode_elements[i];

        var qrcode = new QRCode(qrcode_el, {
          text: qrcode_url,
          width: 250,
          height: 250,
        });

        // Alter generated image
        var img_el = qrcode._el.childNodes[1];
        img_el.classList.add("plain"); // remove border
      }

      // Add text to links : class="qrcode-link"
      var qrcode_link_elements = document.getElementsByClassName("qrcode-link");
      for (var i = 0; i < qrcode_link_elements.length; i++) {
        var link_el = qrcode_link_elements[i];
        link_el.textContent = qrcode_url;
        link_el.href = qrcode_url;
      }
    </script>

    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        controls: true,
        progress: true,
        center: true,
        hash: true,
        history: true,

        navigationMode: "linear",

        transition: "slide", // none/fade/slide/convex/concave/zoom

        parallaxBackgroundImage: "img/background_bond.png",
        parallaxBackgroundSize: "3700px 1600px",

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
        dependencies: [
          {
            src: "plugin/markdown/markdown.js",
            condition: function () {
              return !!document.querySelector("[data-markdown]");
            },
          },

          // Syntax highlight for <code> elements
          { src: "plugin/highlight/highlight.js", async: true },

          { src: "plugin/search/search.js", async: true },

          // Speaker notes
          { src: "plugin/notes/notes.js", async: true },

          // Zoom in and out with Alt+click
          { src: "plugin/zoom-js/zoom.js", async: true },

          // Title-Footer plugin
          { src: "plugin/title-footer/title-footer.js" },
        ],
      });
    </script>
  </body>
</html>
