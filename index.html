<!DOCTYPE html>
<html lang="nb">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <title>PÃ¥skenÃ¸ttknekking med emojier ğŸ‡ - JavaZone 2023</title>

    <meta
      name="description"
      content="PÃ¥skenÃ¸ttknekking med emojier ğŸ‡ - JavaZone 2023"
    />
    <meta name="author" content="Henrik Walker Moe" />

    <meta
      name="viewport"
      content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <meta
      property="og:title"
      content="PÃ¥skenÃ¸ttknekking med emojier ğŸ‡ - JavaZone 2023"
    />
    <meta
      property="og:description"
      content="En gjennomgang av oppgaven 'Andre pÃ¥skedag' fra PSTs pÃ¥ske-CTF 2020"
    />
    <meta property="og:site_name" content="Github" />
    <meta
      property="og:image"
      content="https://henrikwm.github.io/p-sken-tteknekking_med_emojier/img/paskekyllingbetjenter.png"
    />
    <meta property="og:type" content="article" />
    <meta
      property="og:url"
      content="https://henrikwm.github.io/p-sken-tteknekking_med_emojier"
    />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@github" />
    <meta name="twitter:creator" content="@henrikwm" />
    <meta
      name="twitter:title"
      content="PÃ¥skenÃ¸ttknekking med emojier ğŸ‡ - JavaZone 2023"
    />
    <meta
      name="twitter:description"
      content="En gjennomgang av oppgaven 'Andre pÃ¥skedag' fra PSTs pÃ¥ske-CTF 2020"
    />
    <meta
      name="twitter:image"
      content="https://henrikwm.github.io/p-sken-tteknekking_med_emojier/img/paskekyllingbetjenter.png"
    />

    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="msapplication-tap-highlight" content="no" />

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/black.css" id="theme" />
    <link rel="stylesheet" href="dist/custom.css" />

    <!-- Theme used for syntax highlighted code -->
    <link
      rel="stylesheet"
      href="plugin/highlight/zenburn.css"
      id="highlight-theme"
    />

    <!-- Title-Footer plugin -->
    <link rel="stylesheet" href="plugin/title-footer/title-footer.css" />
    <link rel="stylesheet" href="plugin/title-footer/title-footer-custom.css" />

    <!-- Globals -->
    <script type="text/javascript">
      var defaultFooterText =
        "PÃ¥skenÃ¸ttknekking med emojier ğŸ‡ - JavaZone 2023";
    </script>

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement("link");
      link.rel = "stylesheet";
      link.type = "text/css";
      link.href = window.location.search.match(/print-pdf/gi)
        ? "css/print/pdf.css"
        : "css/print/paper.css";
      document.getElementsByTagName("head")[0].appendChild(link);
    </script>

    <!-- QR Codes -->
    <script type="text/javascript" src="lib/qrcode.min.js"></script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- =================== START =================== -->
        <section>
          <section data-source="background_image">
            <p>
              <span class="fragment">henrikwm</span>
              <span class="fragment">@</span>
              <span class="fragment">bekk</span>
            </p>

            <aside class="notes">
              Heisann alle sammen! Og takk for at dere kom for Ã¥ hÃ¸re pÃ¥ meg
              idag! Setter stor pris pÃ¥ at sÃ¥ mange av dere stiller opp pÃ¥
              dagens siste foredrag!<br /><br />

              Fordi det er siste foredrag: hvis det er noen som har noen
              <b>spÃ¸rsmÃ¥l underveis</b>, sÃ¥ kom gjerne opp til meg etterpÃ¥ slik
              at vi <b>runder av i god tid</b><br /><br />

              SÃ¥ len dere tilbake, senke skuldrene. La oss ha det litt gÃ¸y.<br /><br />

              Hvem er jeg? (NESTE)<br /><br />

              Mitt navn er Henrik Walker Moe og jeg jobber i (NESTE) (NESTE)<br />
              Bekk.<br /><br />
              Og idag skal jeg snakke om...
            </aside>
          </section>

          <section data-transition="concave" data-source="bitmoji">
            <div>
              <h2>PÃ¥skenÃ¸ttknekking med emojier ğŸ‡</h2>
              <img src="img/intro_spy_avatar.png" class="plain" />
            </div>

            <aside class="notes">
              <b>PÃ¥skenÃ¸ttknekking med emojier!</b><br /><br />

              * Idag skal vi sammen lÃ¸se en oppgave jeg koste meg med fra
              pÃ¥skenÃ¸ttene til Politiets Sikkerhetstjeneste (PST) fra 2020.<br /><br />

              * PST har i de siste Ã¥rene lagt ut en Capture The Flag (CTF)
              konkurranse i pÃ¥sken. En CTF-oppgave handler om Ã¥ lÃ¸se flere
              deloppgaver til man til slutt finner en skjult kode, ogsÃ¥ kalt et
              "flagg"<br /><br />

              * NÃ¥r man sender inn riktig flagg fÃ¥r man poeng. Den mest flest
              poeng innen konkurransens slutt vinner.<br /><br />
            </aside>
          </section>
        </section>

        <!-- =================== OM MEG ========================================= -->
        <section>
          <section>
            <h2>Hvem er jeg?</h2>

            <aside class="notes">Et par ord om meg</aside>
          </section>

          <section
            data-background="img/intro_henrik_ecotrail.JPG"
            data-source="henrikwm"
          >
            <aside class="notes">
              Jeg...<br />
              * liker Ã¥ lÃ¸pet<br />
              * er sta, har pÃ¥gangsmot <br />
              * liker utfordringer med klare mÃ¥l<br /><br />

              * Sikkerhet er et fagfelt jeg har brukt mye tid i. BÃ¥de som
              fagleder for sikkerhetsfaggruppen vÃ¥r og i vÃ¥r satsning pÃ¥
              sikkerhet i Bekk<br /><br />

              (ANEKDOTE):<br />
              Appropos sikkerhet og JavaZone: hyggelig Ã¥ vÃ¦re tilbake pÃ¥
              JavaZone! Jeg har tidligere snakket om sÃ¸mlÃ¸se
              innloggingslÃ¸sninger, mitt personvernsbidrag til Smittestopp 2 og
              kodeknekking for spioner<br /><br />

              SÃ¥ sikkerhet og kodeknekking er min greie, kan du si.<br /><br />
            </aside>
          </section>

          <section>
            <h3>I â¤ï¸ CTF-er</h3>

            <aside class="notes">
              Og som nevnt, jeg digger CTF-oppgaver!<br /><br />

              * Hvorfor liker jeg CTF'er? <br />
              ** <b>Prosessen</b>: <b>rekognosering</b> og <b>analyse</b> for Ã¥
              forstÃ¥ hvordan man kan <b>utnytte</b> en sÃ¥rbarhet eller knekke en
              kode for Ã¥ finne flagget<br />
              ** <b>MÃ¥ldrevne</b>: delmÃ¥l underveis, motiverer<br />
              ** <b>BelÃ¸nning!</b>: (flagget, viktig spisskompetanse)<br /><br />

              PÃ¥ mange mÃ¥ter er CTF-konkurranser sikkerhetsbransjens e-sport.
              For min del gjÃ¸r det kompetansebygging bÃ¥de gÃ¸y og motiverende nÃ¥r
              jeg vet at neste mestringsfÃ¸lelse er <b>ett flagg</b> unna.
            </aside>
          </section>

          <!--<section>
            <h3>Sikkerhetsfaggruppen â¤ï¸ CTF-er</h3>
            <aside class="notes">
              Vi i Sikkerhetsfaggruppen i Bekk bruker CTF'er aktivt til
              kompetansebygging. BÃ¥de fordi CTF'er ofte er pedagogisk bra lagt
              opp men ogsÃ¥ fordi de er sÃ¥ motiverende Ã¥ jobbe med nÃ¥r du endelig
              finner det flagget du har slitt lenge med Ã¥ finne!<br /><br />

              Idag skal vi sammen kjenne litt pÃ¥ den gleden.
            </aside>
          </section>-->
        </section>

        <!-- =================== OPPGAVEN ======================================= -->
        <section>
          <section>
            <h2>"Andre pÃ¥skedag"</h2>

            <aside class="notes">
              Oppgaven jeg skal ta dere igjennom idag heter
              <b>Andre pÃ¥skedag</b> <br /><br />

              Grunnen til at jeg Ã¸nsker Ã¥ vise dere akkurat denne oppgaven er
              fordi ikke bare var den morsom, den utfordrer deg ogsÃ¥ pÃ¥ viktige
              egenskaper man trenger som problemlÃ¸ser og kodeknekker:<br /><br />

              * analytisk <br />
              * bryte ned problemet<br />
              * kunne verktÃ¸yene<br />
              * forstÃ¥ fagteorien bak problemstillingen man mÃ¥ lÃ¸se<br /><br />

              SÃ¥ er det jo ogsÃ¥ en haug med emojis her som jo er litt spennende!
            </aside>
          </section>

          <section>
            <h3>Vi har fÃ¥tt 3 filer</h3>
            <ul>
              <li>
                <a
                  href="ctf.phst.no/andre_pÃ¥skedag/img/paskekyllingbetjenter.png"
                  >paskekyllingbetjenter.png</a
                >
              </li>
              <li>
                <a href="ctf.phst.no/andre_pÃ¥skedag/merkelig.py">merkelig.py</a>
              </li>
              <li>
                <a href="ctf.phst.no/andre_pÃ¥skedag/underfundig">underfundig</a>
              </li>
            </ul>

            <aside class="notes">
              Oppgaven gir oss disse 3 filene:<br /><br />

              * <b>pÃ¥skekyllingbetjenter.png</b> (bilde)<br />
              * <b>merkelig.py</b> (Python-program)<br />
              * <b>underfundig</b> (fil med emojier)<br /><br />

              Det fÃ¸rste vi mÃ¥ gjÃ¸re er Ã¥ analysere det vi har fÃ¥tt og prÃ¸ve Ã¥
              forstÃ¥ problemstillingen.
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h2>Analyse</h2>
          </section>

          <section>
            <h3>paskekyllingbetjenter.png</h3>
            <img
              data-src="img/paskekyllingbetjenter.png"
              class="plain"
              style="width: 90%"
            />

            <aside class="notes">
              Vi begynner med bildet av pÃ¥skekyllingbetjentene.<br /><br />

              For Ã¥ lete etter ledetrÃ¥der i bilder liker jeg Ã¥ bruke
              Linux-programmene
              <b>file</b> og <b>strings</b>. Ofte finner man skjult tekst i
              bilder og filer i slike CTF'er, og disse programmene hjelper oss Ã¥
              finne dette.
            </aside>
          </section>

          <section>
            <p>
              Analyse med <span class="fragment highlight-green">file</span>:
            </p>
            <pre
              class="fragment fade-up"
            ><code class="python smaller" data-trim data-noescape>
            $ file paskekyllingbetjenter.png

            paskekyllingbetjenter.png: PNG image data, 1920 x 1080, \
            8-bit/color RGBA, non-interlaced
            </code>
            </pre>

            <aside class="notes">
              Jeg starter opp en Linux-terminal i Windows og prÃ¸ver fÃ¸rst med
              programmet <b>file</b> og gir den bildet vÃ¥rt (NESTE):<br /><br />

              * Hva gjÃ¸r <b>file</b> (NESTE)?<br /><br />

              Her fÃ¥r vi bekreftet at vi har et PNG-bilde. Ikke noe mer
              spennende enn det.
            </aside>
          </section>

          <section>
            <p>
              Analyse med <span class="fragment highlight-green">strings</span>:
            </p>
            <pre
              class="fragment fade-up"
            ><code class="python smaller" data-trim data-noescape>
            $ strings paskekyllingbetjenter.png

            ...
            PQ8I9C]
            =g+m*o)
            y|u?
            Io>rw
            K_rA
            l]@?
            %@X@
            rX#s
            2hf
            ...
            </code>
            </pre>

            <aside class="notes">
              Vi prÃ¸ver med <b>strings</b> (NESTE):<br /><br />

              * Hva gjÃ¸r <b>strings</b>? (NESTE) <br /><br />

              * Her ser vi bare masse tulletekst som egentlig er bildedata, og
              det er det. Ikke noe flagg gjemt her heller<br /><br />

              Da mÃ¥ vi innom en tredje analyseteknikk:
              <b>Steganografi</b>-analyse!
            </aside>
          </section>

          <section>
            <p>
              Steganografi-analyse:
              <a
                href="https://github.com/eugenekolo/sec-tools/raw/master/stego/stegsolve/stegsolve/stegsolve.jar"
                >Stegsolve.jar</a
              >
            </p>
            <pre>
              <code data-trim class="python">$ java -jar stegsolve.jar</code>
            </pre>

            <aside class="notes">
              Ã… skjule data i et bilde kalles <b>Steganografi</b><br /><br />

              * Stegsolve: et Java-program som lar oss kikke igjennom
              fargefiltre i bildet<br />
              ** ser etter <b>skjult tekst</b> eller <b>andre skjulte bilder</b
              ><br /><br />

              La oss starte opp Stegsolve og fÃ¸rst kikke pÃ¥ et
              <b>eksempel</b> pÃ¥ hvordan man kan finne en skjult kode i et bilde
            </aside>
          </section>

          <section
            data-transition="fade-in"
            data-source="failOverflow_doge_stege"
          >
            <img
              data-src="img/failOverflow_doge_stege.png"
              class="plain"
              style="width: 70%"
            />

            <aside class="notes">
              Her har jeg funnet fram et bilde fra en annen CTF-oppgave
              <b>doge_stege</b> (<b>Plaid CTF 2014</b>)<br /><br />

              Vi klikker igjennom fargefiltrene i Stegsolve...
            </aside>
          </section>

          <section
            data-transition="none fade-out"
            data-source="failOverflow_doge_stege"
          >
            <img
              data-src="img/insignificant_shark-doge-decoded-highlighted.png"
              class="plain"
              style="width: 70%"
            />

            <aside class="notes">
              Se der!<br /><br />

              I et av fargefiltrene er koden (flagget) man skal finne gjemt:
              <b>pctf{keep_doge_alive_2014}</b><br /><br />

              Vi fÃ¥r se om det skjuler seg noe lignende hos
              pÃ¥skekyllingbetjentene
            </aside>
          </section>

          <section data-source="stegsolve_caesum">
            <img
              data-src="img/paskekyllingbetjenter_stegsolve.gif"
              class="plain"
              style="width: 100%"
            />

            <aside class="notes">
              NÃ¥ har jeg lastet inn bildet av pÃ¥skekyllingbetjentene i
              Stegsolve, og klikker igjennom fargefiltrene<br /><br />

              (VENTE 10s)<br /><br />

              Men vi finner ingenting her heller<br /><br />

              Konklusjon: bildet er bare lokkemat og vi legger bildet til side.
              Vi tar istedet en kikk pÃ¥ denne <b>underfundig</b>-filen
            </aside>
          </section>

          <section>
            <h3>underfundig</h3>
            <img
              data-src="img/underfundig_emojis.png"
              class="plain"
              style="width: 110%"
            />

            <aside class="notes">
              Dette var fil nummer to vi fikk. I <b>underfundig</b>-filen har vi
              1043 emojier pÃ¥ rad og rekke! (stablet de sammen her)<br /><br />

              Tydeligvis noe mening med dette. Vi ser noen emojier repeteres,
              noen bare forekommer en gang. Hva kan det vÃ¦re vi ser her?<br /><br />

              Ellers er ikke sÃ¥ mye mer Ã¥ finne ut her pÃ¥ dette tidspunktet, sÃ¥
              gÃ¥r videre til siste fil
            </aside>
          </section>

          <section>
            <h3>merkelig.py</h3>

            <p>Vi kjÃ¸rer programmet:</p>

            <pre class="shell">
              <span>$ python merkelig.py underfundig</span>              
              <span class="fragment">Passord: <span class="fragment highlight-green">123456</span></span>
              <span class="fragment">Ikke riktig :(</span>                
            </pre>

            <p class="fragment fade-up">ğŸ¥º</p>

            <aside class="notes">
              Siste fil er <b>merkelig.py</b>. Det er et Python-program og
              programmet tar inn <b>underfundig</b>-filen som input. NÃ¥r vi
              prÃ¸ver Ã¥ kjÃ¸re det (NESTE) sÃ¥ spÃ¸r den etter et <b>passord</b
              ><br /><br />

              Vi fÃ¥r skrive noe og se hva som skjer. PrÃ¸ver
              <b>123456</b> (NESTE)<br /><br />

              Programmet sier (NESTE) at passordet ikke er riktig (NESTE).<br /><br />

              Her kan vi lage et hjelpeprogram som bare gjetter seg frem, sÃ¥kalt
              brute-force metoden, som er helt riktig mÃ¥te Ã¥ lÃ¸se oppgaven pÃ¥.
              Men hvorfor gÃ¥ for den enkle lÃ¸sningen?
            </aside>
          </section>

          <section>
            <p>Vi mÃ¥ finne passordet!</p>

            <aside class="notes">
              SÃ¥! Problemstillingen her er klar: finn passordet<br /><br />

              Siden bildet med pÃ¥skekyllingbetjentene bare var lokkemat, og
              <b>underfundig</b>-filen bare en er haug med emojier, sÃ¥ mÃ¥ vi se
              nÃ¦rmere pÃ¥ Python-programmet <b>merkelig.py</b>
            </aside>
          </section>

          <section data-transition="fade-in">
            <h3>merkelig.py</h3>
            <img
              data-src="img/merkelig_py_1.png"
              class="plain"
              style="width: 70%"
            />

            <aside class="notes">
              Hva kan vi tolke fra kildekoden vi ser her?
            </aside>
          </section>

          <section data-transition="none fade-out">
            <h3>merkelig.py</h3>
            <img
              data-src="img/merkelig_py_1_highlighted.png"
              class="plain"
              style="width: 70%"
            />

            <aside class="notes">
              * Vi ser enkelte emojier defineres med en tall-verdi (terning,
              sjokoladeplate, kontroller, hodetelefoner, palett og sukkertÃ¸y)
              <br />

              * Vi ser en funksjon <b>parse_num</b> som omgjÃ¸r sin input til et
              tall<br />

              * Vi ser at <b>underfundig</b>-filen kreves som input for Ã¥ kjÃ¸re
              programmet<br />

              * Vi ser en variabel <b>STACK</b> bli definert som et 256-plasser
              stort register<br />

              * Og vi legger merke til de andre variabelnavnene: <b>PC</b> og
              <b>SP</b>. Navnene er store hint.
            </aside>
          </section>

          <section data-transition="fade-in">
            <h3>merkelig.py</h3>
            <img
              data-src="img/merkelig_py_2.png"
              class="plain"
              style="width: 70%"
            />

            <aside class="notes">
              Videre ned i programmet ser vi en while-lÃ¸kke. Noe skal repeteres
              flere ganger
            </aside>
          </section>

          <section data-transition="none fade-out">
            <h3>merkelig.py</h3>
            <img
              data-src="img/merkelig_py_2_highlighted.png"
              class="plain"
              style="width: 70%"
            />

            <aside class="notes">
              NÃ¥r vi ser hva <b>OP</b>,<b>PC</b>,<b>STACK</b> og
              <b>SP</b> brukes til i hver runde i while-lÃ¸kken, sÃ¥ begynner det
              Ã¥ bli klart hva vi har med Ã¥ gjÃ¸re her
            </aside>
          </section>
        </section>

        <!-- =================== STACK-BASERT VIRTUELL MASKIN =================== -->
        <section>
          <section>
            <h2>Stack-basert virtuell maskin</h2>

            <aside class="notes">
              Det vi har her er en
              <b>Stack-basert virtuell maskin</b>!<br /><br />

              Da jeg fikk vite jeg fikk siste tidsluke pÃ¥ siste dag av JavaZone,
              tenkte jeg: her vil sikkert folk allerede har hodet fullt. Er det
              ikke
              <b>litt ambisiÃ¸st</b> Ã¥ prÃ¸ve Ã¥ forklare hvordan datamaskiner
              kjÃ¸rer programmer og hva en stack-basert virtuell maskin er?<br /><br />

              Men jeg tar utfordringen - dette er ikke bare fjasing med emojier.
              Til og med her skal dere <b>fÃ¥ litt faglig utbytte</b>!
            </aside>
          </section>

          <section data-source="stack_machine">
            <p>Fra Wikipedia:</p>
            <blockquote>
              A "stack machine" is a computer that uses a last-in, first-out
              stack to hold short-lived temporary values. Most of its
              instructions assume that operands will be from the stack, and
              results placed in the stack.
            </blockquote>

            <aside class="notes">
              Python-programmet <b>merkelig.py</b> er vÃ¥r virtuelle maskin og
              <b>underfundig</b>-filen med emojiene er <b>programmet</b> den
              kjÃ¸rer<br /><br />

              Her har noen altsÃ¥ kompilert et program til Ã¥ kjÃ¸re pÃ¥ den
              virtuelle maskinen og "maskinkoden" med data og instruksjoner er
              emojiene i
              <b>underfundig</b>-filen
            </aside>
          </section>

          <section>
            <p>Hva kjennetegner en stack-basert virtuell maskin?</p>
            <ul class="fragment">
              <li>
                <span class="fragment highlight-green">stack</span>: register
                med programmets data
              </li>
              <li>
                <span class="fragment highlight-green">sp</span>: stack pointer
                peker pÃ¥ minneadressen som inneholder neste posisjon (toppen) av
                stacken
              </li>
              <li>
                <span class="fragment highlight-green">pc</span>: program
                counter (programteller) vet i hvilken minneadresse den finner
                neste instruks/data
              </li>
              <li>
                <span class="fragment highlight-green">op</span>: operand
                (<b>pop</b>, <b>push</b>, <b>jmp</b>, <b>xor</b> osv.)
              </li>
            </ul>

            <aside class="notes">
              Hva kjennetegner en stack-basert virtuell maskin: (NESTE x2)<br /><br />

              * STACKen er minneregisteret hos den virtuelle maskinen som tar
              vare pÃ¥ programmets data og instruksjoner nÃ¥r programmet kjÃ¸rer.
              Som vi sÃ¥ tidligere har denne virtuelle maskinen 256 minneadresser
              (NESTE)<br /><br />

              * SP (stack-pointer) peker pÃ¥ minneadressen til toppen av stacken
              (NESTE)<br /><br />

              * PC (program counter) er programtelleren, ogsÃ¥ kalt
              instruksjonspeker, som holder styr pÃ¥ rekkefÃ¸lgen av instruksjoner
              som kjÃ¸res. Den vet i hvilken minneadresse pÃ¥ stacken programmet
              skal finne neste data eller instruksjon (NESTE)<br /><br />

              * OP er operanden (instruksjonen) som programmet Ã¸nsker at
              maskinens hjerne (gjerne CPU-en i en datamaskin) skal utfÃ¸re for
              oss.<br />
              Push legger til data pÃ¥ stacken og Pop leser ut data fra
              stacken.<br />
              Jmp forteller programmet at det skal hoppe til et sted i
              minnet.<br />
              XOR er en av flere vanlige binÃ¦roperasjoner man kan gjÃ¸re pÃ¥ data
              (man har ofte i tillegg AND, OR osv.)
            </aside>
          </section>

          <section data-source="wiki_callstack">
            <img
              data-src="img/call_stack_layout.svg.png"
              class="plain"
              style="width: 70%"
            />

            <aside class="notes">
              Vi kan godt se for oss en mental modell av en STACK slik. Her med
              et eksempel som et grafikkprogram og den har to subrutiner
              "DrawLine" og "DrawSquare".<br /><br />

              Hver av disse subrutinene har plassert sine data i minneadressene
              pÃ¥ maskinens STACK.<br /><br />

              Se for deg her en datamaskin med flere gigabytes med minne og
              mange programmer som kjÃ¸rer samtidig. Stack pointer og program
              counter holder styr pÃ¥ hvor neste data og instrukser er slik at
              det ikke blir helt kaos.<br /><br />

              ANEKDOTE 1: Hvis programmer gjÃ¸r noe galt og fyller opp hele
              stacken (typisk hvis man lager en evig loop ved et uhell), da fÃ¥r
              man StackOverflow-feil. StackOverflow.com er jo en nettside noen
              her kanskje sikkert kjenner til...<br /><br />

              ANEKDOTE 2: Noen tenker kanskje at hvis man klarer Ã¥ manipulere
              disse minneadressene og fÃ¥ et program til Ã¥ lese annen data, eller
              peke til et annet sted i minne hvor du vil at den istedet skal
              lete, sÃ¥ er det nyttig manipulasjon Ã¥ kunne.<br />
              Og det er helt riktig. Slik hacking gjÃ¸r at man f.eks. kan cracke
              programmer og lese hemmeligheter fra minnet pÃ¥ datamaskinen.
            </aside>
          </section>

          <section>
            <p>
              Alle operand-emojiene <b>underfundig</b> inneholder:<br />
              <br />
              ğŸ°ğŸ¥ğŸŒ±ğŸŒ»ğŸ‡ğŸ¥šğŸ¤ğŸ£ğŸŒ
              <br />
            </p>
            <p class="fragment">
              er
              <span class="fragment highlight-green">maskininstruksjoner</span>!
            </p>

            <aside class="notes">
              SÃ¥ nÃ¥ vet vi litt mer om STACKen og hvordan programmet kjÃ¸rer, sÃ¥
              vi gÃ¥r videre med emojiene vÃ¥re.<br /><br />

              Vi vet nÃ¥ at alle operandene vi ser i <b>underfundig</b>-filen er
              (NESTE x2)...<br /><br />
              <b>maskininstruksjoner</b> til et program som kjÃ¸rer pÃ¥ denne
              virtuelle maskinen!
            </aside>
          </section>

          <section>
            <pre
              class="even-less-spacing"
            ><code class="python smallester" data-trim data-noescape>
              (...)
              elif op == "ğŸ¥": # 1. kylling tilsvarer assembly-instruksjonen "PUSH"
                  stack[sp] = stack[sp-1]
                  sp += 1
              elif op == "ğŸŒ±": # 2. frÃ¸ tilsvarer assembly-instruksjonen "ADD"
                  sp -= 1
                  stack[sp-1] += stack[sp]
                  stack[sp-1] %= base**4
              elif op == "ğŸŒ»": # 3. solsikke tilsvarer assembly-instruksjonen "SUB"
                  sp -= 1
                  stack[sp-1] -= stack[sp]
                  stack[sp-1] %= base**4
              elif op == "ğŸ‡": # 4. kanin tilsvarer assembly-instruksjonen "JMP"
                  sp -= 1
                  if stack[sp] != 0:
                      pc += parse_num(code[pc:pc+4])
                  else:
                      pc += 4
              (...)
            </code></pre>

            <aside class="notes">
              Vi kjenner igjen mange av disse operandene i den virtuelle
              maskinen. Flere ligner litt pÃ¥ kjente instruksjoner fra
              assembly-sprÃ¥k (det sprÃ¥ket CPU'en, hjernen i datamaskinen,
              forstÃ¥r):<br /><br />

              * Pkt.1: <b>kylling</b> flytter gjeldende stack-verdi i stacken en
              plass ned i stack-registeret, altsÃ¥ "push"<br />
              * Pkt.2: <b>spire</b> gjÃ¸r blant annet addering mellom to
              stack-verdier, altsÃ¥ "add"<br />
              * Pkt.3: <b>solsikke</b> gjÃ¸r blant annet subtraksjon mellom to
              stack-verdier, altsÃ¥ "sub"<br />
              * Pkt.4: ...og <b>kaninen</b> hopper til ny instruksjon eller
              videre i programmet, altsÃ¥ "jump"<br /><br />

              SÃ¥ nÃ¥r vi sammenligner alle operandene i denne virtuelle maskinen
              med noe som ligner LITT pÃ¥ mer kjente maskininstruksjoner som
              CPU'ene i vÃ¥re datamaskiner forstÃ¥r...
            </aside>
          </section>

          <section>
            <p>Operander og maskininstrukser i den virtuelle maskinen:</p>
            <table>
              <thead>
                <tr>
                  <th>Emoji-operand</th>
                  <th>Tilsvarer instruksjon</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>ğŸ‡</td>
                  <td>jmp</td>
                </tr>
                <tr>
                  <td>ğŸ¥</td>
                  <td>push</td>
                </tr>
                <tr>
                  <td>ğŸŒ»</td>
                  <td>pop_sub</td>
                </tr>
                <tr>
                  <td>ğŸŒ±</td>
                  <td>pop_add</td>
                </tr>
                <tr>
                  <td>ğŸ¥š</td>
                  <td>xor (âŠ•)</td>
                </tr>
                <tr>
                  <td>...</td>
                  <td>...</td>
                </tr>
              </tbody>
            </table>

            <aside class="notes">
              ...sÃ¥ fÃ¥r vi dette! Har man erfaring med assembly-sprÃ¥k og lavnivÃ¥
              programmering sÃ¥ kjenner man igjen hva alle disse operandene i vÃ¥r
              virtuelle maskin tilsvarer:<br /><br />

              * operanden kanin "hopper" (jump)<br />
              * kylling er "push" <br />
              * solsikke er "pop" og "sub"<br />
              * spire er "pop" og "add"<br />
              * egg er XOR (en binÃ¦rmatematikk som regner pÃ¥ to faktorer). XOR i
              CTF-er er gjerne brukt til enkel kryptering... interessant!
            </aside>
          </section>

          <section>
            <p>
              <b>underfundig</b> er et program som er
              <span class="fragment highlight-green">kompilert</span> til
              emojier
            </p>
            <br />
            <p class="fragment">
              kan vi <span class="fragment highlight-green">dekompilere</span>
              programmet tilbake til menneskelesbar kildekode?
            </p>

            <aside class="notes">
              NÃ¥r man lager programmer sÃ¥ kompilerer (NESTE) man kildekoden med
              en kompilator, som omgjÃ¸r menneskelesbar kildekode til lavnivÃ¥
              maskininstrukser som maskinen kan forstÃ¥ og kjÃ¸re<br /><br />

              <b>underfundig</b>-filen kan man si er "kompilert" til emojier
              slik at den kan kjÃ¸res pÃ¥ denne virtuelle maskinen i
              <b>merkelig.py</b><br /><br />

              Hvis vi kan reversere (NESTE) det kompilerte programmet tilbake
              til menneskelesbar kildekode, dvs. dekompilere (NESTE) det, sÃ¥ kan
              vi kanskje forstÃ¥ hva programmet gjÃ¸r og finne det passordet vi er
              pÃ¥ jakt etter
            </aside>
          </section>
        </section>

        <!-- =================== DEKOMPILERING =================== -->
        <section>
          <section>
            <h2>Dekompilering</h2>
          </section>

          <section>
            <p>
              For Ã¥ lage et dekompileringsprogram mÃ¥ vi forstÃ¥
              <b>underfundig</b> litt bedre
            </p>

            <aside class="notes">
              Vi lÃ¦rte at <b>underfundig</b>-programmet inneholder operander,
              men for Ã¥ dekompilere hele programmet mÃ¥ vi ogsÃ¥ vite hva resten
              av emojiene er
            </aside>
          </section>

          <section>
            <p>Finner vi et mÃ¸nster i emojiene?</p>
            <div class="fragment fade-up">
              <p>ğŸ°ğŸ®ğŸ«ğŸ®ğŸ²ğŸ¤ğŸ°ğŸ«ğŸ¨ğŸ®ğŸ²ğŸ¤ğŸ°ğŸ«ğŸ«ğŸ§ğŸ²ğŸ¤</p>
              <p>-</p>
            </div>

            <div class="fragment fade-up">
              <p>ğŸ°ğŸ¥ğŸŒ±ğŸŒ»ğŸ‡ğŸ¥šğŸ¤ğŸ£ğŸŒ</p>
              <p>=</p>
            </div>

            <div class="fragment fade-up">
              <p>ğŸ®ğŸ«ğŸ®ğŸ²ğŸ«ğŸ¨ğŸ®ğŸ²ğŸ«ğŸ«ğŸ§ğŸ²</p>
            </div>

            <aside class="notes">
              Kanskje kan vi finne et mÃ¸nster i underfundig-emojiene? (NESTE)
              <br /><br />

              * Dette er de fÃ¸rste emojiene i
              <b>underfundig</b>-filen...(NESTE)<br />

              * Hvis vi tar vekk de operand-emojiene som vi vet er
              maskininstruksjoner (NESTE)<br />

              * Hva sitter vi igjen med da?<br /><br />

              Kan dette vÃ¦re data, altsÃ¥ bokstaver og tall, som programmet
              bruker til noe?
            </aside>
          </section>

          <section>
            <p>
              Vi vet hva som er operander: <br />
              ğŸ°ğŸ¥ğŸŒ±ğŸŒ»ğŸ‡ğŸ¥šğŸ¤ğŸ£ğŸŒ
            </p>
            <br />
            <p>I <b>merkelig.py</b> sÃ¥ vi:</p>
            <pre><code class="python" data-trim data-noescape>
            digits = {"ğŸ²": 0, "ğŸ«": 1,  "ğŸ®": 2, "ğŸ§": 3, "ğŸ¨": 4, "ğŸ¬": 5}
            </code></pre>
            <br />
            <p>SÃ¥ vi vet at disse er data: <br />ğŸ²ğŸ«ğŸ®ğŸ§ğŸ¨ğŸ¬</p>

            <aside class="notes">
              Siden vi nÃ¥ vet hvilke emojier som er operander og hvilke som er
              data, sÃ¥ har vi det vi trenger for Ã¥ dekompilere programmet
            </aside>
          </section>

          <section>
            <p>
              Vi lager et nytt Python-program
              <b>underfundig_dekompilering.py</b>:
            </p>
            <pre class="even-less-spacing">
              <code class="python" data-trim data-noescape>
              code = open(sys.argv[1], "rt", encoding="utf-8").read()

              write_decoded_commands(code) # code=innholdet i underfundig-filen
              </code>
            </pre>

            <p>KjÃ¸rer programmet:</p>

            <pre>
              <code class="python" data-trim data-noescape>
              $ python underfundig_dekompilering.py underfundig
              </code>
            </pre>

            <p>som lager en ny fil: <b>underfundig_dekompilering_output</b></p>

            <aside class="notes">
              Vi lager oss hjelpeprogrammet
              <b>underfundig_dekompilering.py</b> som inneholder en funksjon
              <b>write_decoded_commands</b>: <br />

              * den funksjonen tar inn alt innholdet i <b>underfundig</b>-filen
              <br />
              * deretter oversetter den emojiene til operander og data<br />
              * og tilslutt skriver resultatet til en fil
              <b>underfundig_dekompilering_output</b><br /><br />

              ForhÃ¥pentligvis viser filen oss hva hver emoji egentlig gjÃ¸r i den
              rekkefÃ¸lgen som programmet kjÃ¸rer.<br /><br />

              Vi kjÃ¸rer hjelpeprogrammet i terminalen vÃ¥r og i filen vÃ¥r ser
              vi...
            </aside>
          </section>

          <section>
            <img
              data-src="img/underfundig_dekompilert.png"
              class="plain"
              style="width: 30%"
            />

            <aside class="notes">
              Dette! Linje for linje ser vi alle operandene og emoji-dataene som
              programmet bestÃ¥r av: <br /><br />

              * Ã˜verst pÃ¥ steg 0 i programmet: <b>Hare</b> leser inn de neste 4
              emojiene fra <b>STACK'en</b><br />

              * Under ser vi de 4 data-emojiene (tallverdi 80, 80 i
              ASCII-tabellen er bokstaven "P"). ASCII-tabellen er en liste over
              alle tegn pÃ¥ tastaturet ditt, hvor hver tegn har en tallverdi<br />

              * PÃ¥ steg 5 i programtelleren: <b>Kylling</b> skriver "P" ut til
              terminalen min <br /><br />

              SÃ¥ vi klarer nÃ¥ Ã¥ lese at det fÃ¸rste programmet gjÃ¸r er Ã¥ skrive
              ut "Passord:" til terminalen min, slik vi sÃ¥ det gjorde tidligere
              da jeg testet Ã¥ kjÃ¸re <b>merkelig.py</b>
            </aside>
          </section>

          <section>
            <p>I <b>merkelig.py</b> sÃ¥ vi:</p>
            <pre><code class="python" data-trim data-noescape>
            if op == "ğŸ°":
              stack[sp] = parse_num(code[pc:pc+4]) # les inn 4 emojier
              sp += 1
              pc += 4
            </code></pre>
            <p>ğŸ° leser 4 emojier av gangen og omgjÃ¸r til et tall</p>

            <aside class="notes">
              Vi har forstÃ¥tt at <b>hare</b>-operanden i den virtuelle maskinen
              vÃ¥r leser inn 4 tegn av gangen<br /><br />

              Og tilbake fra <b>parse_num</b>-funksjonen fÃ¥r vi et tall...<br /><br />

              Hva slags tall er disse 4 og 4 data-emojiene tro?
            </aside>
          </section>

          <section>
            <p>Data-emojiene ser ut til Ã¥ vÃ¦re bokstaver!</p>
            <table>
              <tr>
                <td></td>
                <td>ğŸ®ğŸ«ğŸ®ğŸ²</td>
                <td>ğŸ«ğŸ¨ğŸ®ğŸ²</td>
                <td>ğŸ«ğŸ«ğŸ§ğŸ²</td>
                <td>ğŸ«ğŸ«ğŸ§ğŸ²</td>
              </tr>
              <tr>
                <td>ASCII-tallverdi</td>
                <td>80</td>
                <td>97</td>
                <td>115</td>
                <td>115</td>
              </tr>
              <tr>
                <td>Bokstav</td>
                <td class="fragment highlight-green">P</td>
                <td class="fragment highlight-green">a</td>
                <td class="fragment highlight-green">s</td>
                <td class="fragment highlight-green">s</td>
              </tr>
            </table>

            <aside class="notes">
              Jo! Det viser seg at flere av data-emojiene i
              <b>underfundig</b>-programmet er tekst! Dekompileringen vi nettopp
              gjorde viste oss 4 og 4 av disse emojiene (NESTE x4)<br /><br />

              Her ser vi at de fÃ¸rste data-emojiene gir oss "Pass", som vi antar
              er "Passord" (det programmet skrev ut da den ba oss om Ã¥ skrive
              inn et passord istad)<br /><br />

              Kan vi lage et Python-program som skriver ut all den skjulte
              teksten i hele
              <b>underfundig</b>-programmet tro? Litt som nÃ¥r vi bruker
              programmet <b>strings</b> pÃ¥ Linux for Ã¥ finne skjult tekst i
              filer, i grunn.
            </aside>
          </section>

          <section>
            <p>
              Vi lager et nytt program
              <b>lÃ¸sning.py</b> som henter ut alle bokstaver i
              <b>underfundig</b>:
            </p>

            <pre>
              <code class="python" data-trim data-noescape>
              text = extract_text(underfundig_content)

              print(text)
              </code>
            </pre>

            <div class="fragment">
              <p>og kjÃ¸rer programmet:</p>
              <pre>
                <code class="python" data-trim data-noescape>
                $ python lÃ¸sning.py underfundig
                </code>
              </pre>
            </div>

            <aside class="notes">
              Vi lager oss et nytt program som blir starten pÃ¥ lÃ¸sningen:
              <b>lÃ¸sning.py</b>: <br />

              * programmet inneholder en funksjon <b>extract_text</b> som
              oversetter alle data-emojiene til ASCII-tallverdier<br />

              * og sÃ¥ gjÃ¸r den om disse ASCII-tallverdiene til ASCII-tegn slik
              at tallene blir til bokstaver og tegn vi kjenner igjen fra vÃ¥rt
              tastatur (NESTE)<br /><br />

              Vi kjÃ¸rer programmet og gir den <b>underfundig</b>-filen som input
            </aside>
          </section>

          <section>
            <h3>
              <span class="fragment highlight-green">Passord:</span>
              <span class="fragment highlight-green">"</span
              ><span class="fragment highlight-green"
                >w*4*D*T*W*J*7*A*Y*f*`*j*n***}*4*\x9d*Ã§*Â¿*Ä„*Å*ÅŠ*Å¦*Ä±*Æ‰*Ç“*Ç‘*Ç*Ç*Ç‡*Ç¦*Çœ*Æ¹*È›*Éµ</span
              ><span class="fragment highlight-green"
                >Gratulerer! Flagget vet du allerede :)\nIkke riktig :(\n</span
              >
            </h3>

            <aside class="notes">
              Og dette er det vi fÃ¥r. Spennende! Her ser vi all teksten som
              programmet inneholder!<br /><br />

              Vi kjenner igjen noe av teksten: (NESTE)<br />

              * 'Passord: ' er det programmet skriver ut til terminalen nÃ¥r den
              ber om passordet (NESTE)<br />

              * sÃ¥ har vi et hermetegn (NESTE)<br />

              * og sÃ¥ mange kryptiske tegn i ca. strukturert form (annenhver
              tegn og stjerne) (NESTE)<br />

              * Til slutt 'Gratulerer! Flagget vet du allerede smilefjes' og
              'Ikke riktig'. Som er teksten programmet gir oss ved galt eller
              riktig passord
              <br /><br />

              Vi vet at den teksten som vi kan lese her er det programmet selv
              skriver ut. Jeg er mye mer interessert i den
              <b>ikke-lesbare teksten her</b>. Jeg mistenker sterkt at dette er
              chifferteksten (dvs. det krypterte passordet) vi er ute etter!
            </aside>
          </section>

          <section>
            <p>w*4*D*T*W*J*7*A*Y*f*`*j*n***}*4*</p>
            <p>\x9d*Ã§*Â¿*Ä„*Å*ÅŠ*Å¦*Ä±*Æ‰*Ç“*Ç‘*Ç*Ç*Ç‡*Ç¦*Çœ*Æ¹*È›*Éµ</p>
            <br />
            <h3 class="fragment fade-up">ğŸ•µï¸â€â™€ï¸ğŸ•µï¸â€â™‚ï¸</h3>

            <aside class="notes">
              SÃ¥ dette er chifferteksten vi mÃ¥ dekryptere og vÃ¥r neste
              utfordring (NESTE)<br /><br />

              Vi trenger Ã¥ forstÃ¥ hvordan chifferteksten har blitt kryptert slik
              at vi kan dekryptere den. Da er jeg rimelig sikker pÃ¥ at vi har
              passordet og flagget vÃ¥rt
            </aside>
          </section>
        </section>

        <!-- =================== DEKRYPTERING =================== -->
        <section>
          <section>
            <h2>Dekryptering</h2>
          </section>

          <section>
            <p>
              MÃ¥let vÃ¥rt nÃ¥ er Ã¥ dekryptere chifferteksten til noe som ligner
              flaggformatet <b class="fragment highlight-green">PHST{...}</b>
            </p>

            <aside class="notes">
              MÃ¥let vÃ¥rt nÃ¥ er Ã¥ se om vi kan dekryptere chifferteksten til noe
              som ligner flaggformatet som CTF-oppgaven forventer (NESTE):<br /><br />

              PHST{...} (pÃ¥skeharens sikkerhetstjeneste med passordet imellom
              krÃ¸llparantesene)
            </aside>
          </section>

          <section>
            <p>
              Vi endrer litt pÃ¥ <b>merkelig.py</b>: <br />skriv ut hele stacken
              for hver operand-instruksjon som blir utfÃ¸rt
            </p>
            <pre><code class="python" data-trim data-noescape>
            $ python merkelig.py underfundig
            Passord: tulleinput
            </code></pre>

            <aside class="notes">
              Jeg er interessert i XOR-operanden (egg-emojien) vi sÃ¥
              <b>underfundig</b>-programmet brukte tidligere. Jeg mistenker den
              brukes til kryptering men jeg mÃ¥ ha full oversikt over alt som
              skjer og dataverdier i stacken, nÃ¥r <b>underfundig</b>-programmet
              kjÃ¸res, for Ã¥ forstÃ¥ nÃ¸yaktig hva som skjer<br /><br />

              SÃ¥ vi tilpasser <b>merkelig.py</b> slik at vi ser det samme som
              maskinen ser nÃ¥r <b>underfundig</b>-programmet kjÃ¸res. Dette er
              vanlige verktÃ¸y vi utviklere bruker i hverdagen, her bygger jeg et
              slikt verktÃ¸y selv. Vi Ã¸nsker Ã¥ se hva vi har "pÃ¥ stacken" nÃ¥r
              programmet kjÃ¸rer.<br /><br />

              Vi kjÃ¸rer <b>merkelig.py</b> igjen, gir passordet "tulleinput",
              slik at vÃ¥r oversikt over innholdet i stacken kan genereres
            </aside>
          </section>

          <section>
            <pre class="shell bigger">
              <pre class="" data-trim data-noescape>
              (...) t , u , l , l , e , i , n , p , u , t
              ğŸ£:116,117,108,108,101,105,110,112,117,116,(10) (...)
              ğŸ£:116,117,108,108,101,105,110,112,117,116,10,(0) (...)
              ğŸ°:116,117,108,108,101,105,110,112,117,116,10,(34) (...)
              ğŸ°:116,117,108,108,101,105,110,112,117,116,10,34,(0) (...)
              ğŸŒ»:116,117,108,108,101,105,110,112,117,116,10,(34) (...)
              ğŸŒ»:116,117,108,108,101,105,110,112,117,116,<mark>-24</mark>,(34) (...) 
              ğŸŒ»:116,117,108,108,101,105,110,112,117,116,<mark>1272</mark>,(34) (...) 
              ğŸ‡:116,117,108,108,101,105,110,112,117,116,(1272),34 (...) 
              ğŸ°:116,117,108,108,101,105,110,112,117,116,<mark>(73)</mark>,34 (...) 
              (...)
              </pre>
            </pre>
            <p>
              <b>tulleinput</b> gir et negativt tallverdi pÃ¥ stacken som gjÃ¸r at
              programmet alltid hopper til "Ikke riktig :("
            </p>

            <aside class="notes">
              Her er stacken, et register med 256-minneplasser, skrevet ut
              bortover mot hÃ¸yre med 256 plasser med data. Stacken er en "Last
              in, first out"-stack som betyr at plassen som er lengst mot hÃ¸yre
              er dataverdien som er sist lagt pÃ¥ stacken<br /><br />

              Hver linje er den rekkefÃ¸lgen instruksene har kjÃ¸rt, gjerne kalt
              en kall-stack av oss utviklere.<br /><br />

              Vi ser at <b>underfundig</b>-programmet har lest inn passordet
              vÃ¥rt <b>tulleinput</b> inn pÃ¥ stacken som ASCII-tallverdier<br /><br />

              Det vi kan tolke her er at <b>tulleinput</b> stadig vekk er feil
              passord. Etter passordet vÃ¥rt ser vi 34 og sÃ¥ et negativt tall
              (-24), og kaninen ber programmet hoppe til 1272, som er starten pÃ¥
              "Ikke riktig :("-feilmeldingen (ASCII-tallet 73 er "I"). Stacken
              videre nedover viser at programmet skriver ut denne beskjeden til
              min terminal
            </aside>
          </section>

          <section>
            <p>
              Etter mange forsÃ¸k ulike passord med ulike lengder, og observasjon
              av forandringer i stacken...
            </p>
            <p class="fragment">Hvis passordet er 34 tegn langt...</p>

            <aside class="notes">
              Etter mye prÃ¸ving av flere passord og observasjon av stacken...<br />

              sÃ¥ jeg at tallet 34 forekom ofte pÃ¥ toppen av stacken etter at
              passordet var lest inn (NESTE)<br /><br />

              og da jeg testet et passord som var 34 tegn langt...
            </aside>
          </section>

          <section>
            <p>Passord <b>tulleinput123456789123456789123456</b> gir:</p>
            <pre class="shell bigger">
              <pre class="" data-trim data-noescape>
              (...)     9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6
              ğŸŒ»:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,0,(<mark>34</mark>) (...)
              ğŸ‡:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,<mark>(0)</mark>,34 (...)
              ğŸ°:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,(119),34 (...)
              ğŸ°:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,119,(34) (...)
              ğŸ¥š:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,(119),34 (...)
              ğŸ¥š:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,65,(119),34 (...)
              ğŸ°:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,65,(42),34 (...)
              ğŸ°:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,65,42,(34) (...)
              (...)
              </pre>
            </pre>

            <p class="fragment">
              Programmet kjÃ¸rte litt lenger nÃ¥, vi har kommet til ğŸ¥š (âŠ•)
            </p>

            <aside class="notes">
              sÃ¥ er 34 der igjen, men noe mer har skjedd (NESTE)<br /><br />

              Programmet kjÃ¸rte visst <b>videre</b> til nye instrukser nÃ¥ og vi
              ser egget (XOR) blir brukt! XOR som vi istad snakket om ofte blir
              brukt til kryptering.
            </aside>
          </section>

          <section>
            <p>
              ASCII-tallet <b>34</b> er tegnet
              <span class="fragment highlight-green">"</span>
            </p>
            <p>
              I teksten vi fant i <b>underfundig</b>: <br />
              <span class="fragment highlight-green"
                >Passord: "w*4*D*T*W(...)</span
              ><br />
              ...finner vi tegnet
              <span class="fragment highlight-green"><b>"</b></span>
            </p>
            <p class="fragment">
              Vi har funnet programmets konstant for passordlengde! ğŸ˜
            </p>

            <aside class="notes">
              Tallet 34 (NESTE) i ASCII-tabellen er et "hermetegn"<br /><br />

              I den skjulte teksten i underfundig (NESTE) fant vi jo et
              hermetegn (NESTE x2)<br /><br />

              Vi ser ut til Ã¥ ha funnet programmets konstant for passordlengde!
              Programmet gir alltid feilmelding hvis passordet vi gir ikke er 34
              tegn langt
            </aside>
          </section>

          <section>
            <p>Passord <b>tulleinput123456789123456789123456</b>:</p>
            <pre class="shell bigger">
              <pre data-trim data-noescape>
              (...)     9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6
              ğŸŒ»:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,0,(34) (...)
              ğŸ‡:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,(<mark>0</mark>),34 (...)
              ğŸ°:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,(119),34 (...)
              ğŸ°:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,119,(34) (...)
              ğŸ¥š:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,<mark>54,(119)</mark>,34 (...)
              ğŸ¥š:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,<mark>65</mark>,(119),34 (...)
              ğŸ°:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,65,(42),34 (...)
              ğŸ°:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,65,42,(34) (...)
              (...)
              </pre>
            </pre>
            <p>
              Hvis gjeldende stack-verdi er "0" nÃ¥r ğŸ‡ operanden kjÃ¸res, gÃ¥r den
              videre til XOR-operanden
            </p>
            <p class="fragment">119 âŠ• 54 = 65</p>

            <aside class="notes">
              Tilbake til det lange tullepassordet. Vi vet nÃ¥ at passordets
              lengde skal vÃ¦re 34 tegn langt. Da kjÃ¸rer programmet videre og
              gjÃ¸r XOR-operasjoner med innholdet pÃ¥ stacken, altsÃ¥ tegnene i
              passordet vÃ¥rt<br /><br />

              Det viser seg at det er en sammenheng her: kanin-operanden har
              alltid tallverdi "0" som gjeldende stack-verdi nÃ¥r det senere
              XOR-es (NESTE)<br /><br />

              Her blir fÃ¸rste tegn i chifferteksten ("w", <b>119</b>) XOR'et med
              siste tegn i tullepassordet jeg oppga ("6", <b>54</b>). Og svaret
              <b>65</b>
              puttes pÃ¥ stacken. SÃ¥ krypteringsalgoritmen ligger foran oss her,
              hvis vi klarer Ã¥ forstÃ¥ faktorene som det XORes med
            </aside>
          </section>

          <section>
            <p>
              I <b>merkelig.py</b> hopper ğŸ‡ alltid videre til
              feilmeldingsteksten hvis gjeldende verdi pÃ¥ stacken er forskjellig
              fra <b>0</b>:
            </p>
            <pre><code class="python smaller" data-trim data-noescape>
            elif op == "ğŸ‡":
            sp -= 1
            if stack[sp] != 0: # skal kaninen hoppe til ny instruks eller ikke?
                pc += parse_num(code[pc:pc+4]) # hopp til ny instruks (feilmelding)
            else:
                pc += 4 # programmet gÃ¥r videre til neste instruks
            </code></pre>
            <p class="fragment">
              FÃ¥r vi gjeldende stack-verdi til Ã¥ vÃ¦re <b>0</b> sÃ¥ kjÃ¸rer
              programmet videre til neste instruks istedet
            </p>

            <aside class="notes">
              Kaninen er nÃ¸kkelen for Ã¥ komme videre. Hvis den er noe annet enn
              0, sÃ¥ hoppes det til ny instruks fra <b>underfundig</b>-programmet
              og programmet skriver ut "Ikke riktig"-feilmeldingen (NESTE)<br /><br />

              Men er gjeldende verdi pÃ¥ stacken nÃ¥r kaninen-operanden kjÃ¸res
              tallet null, sÃ¥ kjÃ¸rer programmet videre. Det er det Ã¸nsker vi Ã¥
              fÃ¥ til!
            </aside>
          </section>

          <section>
            <p>
              Ved Ã¥ analysere stacken nÃ¦rmere, kan vi regne oss fram til hva som
              skal til for at ğŸ‡ operanden fÃ¥r <b>0</b> som gjeldende
              stack-verdi?
            </p>
            <pre
              class="less-spacing"
            ><code class="shell smallest" data-trim data-noescape>
            ğŸ¥š:(...) 53,54,(119),34 (...) # 4. Hvis z er 10, sÃ¥ mÃ¥ 119 XOR 10 = 125 = }
            ğŸ¥š:(...) 53,z,(119),34 (...)
            ğŸ°:(...) 53,z,(42),34 (...)
            ğŸ°:(...) 53,z,42,(34) (...)
            ğŸŒ±:(...) 53,z,(42),34 (...) # 3. Her mÃ¥ z vÃ¦re 10, fordi 10 + 42 mÃ¥ bli 52
            ğŸŒ±:(...) 53,y,(42),34 (...)
            ğŸŒ±:(...) 53,y,(42),34 (...)
            ğŸ¥:(...) 53,107,(y),34 (...)
            ğŸ¥:(...) 53,107,y,(34) (...)
            ğŸ°:(...) 53,107,y,(52) (...)
            ğŸ°:(...) 53,107,y,52,(0) (...)
            ğŸŒ»:(...) 53,107,y,(52) (...) # 2. Her mÃ¥ y vÃ¦re 52, fordi 52 - 52 mÃ¥ bli 0
            ğŸŒ»:(...) 53,107,x,(52) (...)
            ğŸŒ»:(...) 53,107,x,(52) (...)
            ğŸ‡:(...) 53,107,(x),52 (...) # 1. x skal vÃ¦re 0
            </code></pre>
            <p class="fragment">
              119 âŠ• (52-42) = <span class="fragment highlight-green">125</span>,
              dvs. ASCII-tegnet
              <span class="fragment highlight-green"><b>}</b></span> ğŸ˜
            </p>

            <aside class="notes">
              Hvordan skal vi sÃ¸rge for at kaninen ikke hopper videre til
              feilmelding? PÃ¥ pkt. 1 nederst i stacken her mÃ¥ vi ha
              <b>0</b> som stack-verdi nÃ¥r kanin-operanden blir kjÃ¸rt. Vi regner
              oss bakover fra stack-verdien hos kaninen og oppover i
              stack-verdiene. Jeg bruker x, y og z som variabler for Ã¥ gjÃ¸re
              regnestykket enklere:<br />

              * Pkt 1. x mÃ¥ vÃ¦re 0<br />
              * Pkt 2. y mÃ¥ vÃ¦re 52 fordi her er operasjonen subtraksjon: 52
              minus 52 = 0.<br />
              * Pkt 3. z mÃ¥ vÃ¦re 10 fordi her er operasjonen addering: 10 + 42
              mÃ¥ bli 52<br />
              * Pkt 4. Hvis z er 10, sÃ¥ kan vi bruke XOR med 119 og 10 regne oss
              fram til det siste tegnet i det <b>ukrypterte</b> passordet
              (NESTE)<br /><br />

              119 XOR 10 = 125 (NESTE)(NESTE), ASCII-tallet 125 er ASCII-tegnet
              "krÃ¸llparantes".
            </aside>
          </section>

          <section>
            <h3>Algoritmen</h3>

            <p>kryptert tegn XOR (n+2 - n+1) = dekryptert tegn</p>

            <aside class="notes">
              Vi har her en algoritme, en fremgangsmÃ¥te som gir oss ett og ett
              dekryptert tegn fra chifferteksten:<br /><br />

              * ta fÃ¸rste tegn i chifferteksten, XOR det med tegnet 2 plasser
              bort, minus tegnet 1 plass bort. Svaret er en ASCII-tallverdi som
              representerer vÃ¥r fÃ¸rste dekrypterte tegn!
            </aside>
          </section>

          <section>
            <p>
              <span class="fragment highlight-green">w</span
              >*4*D*T*W*J*7*A*Y*f*`*j (...)
            </p>

            <p class="fragment">w XOR (4-*)</p>

            <p class="fragment">
              ...med ASCII-tallverdier:<br />
              119 XOR (52-42) =
              <span class="fragment highlight-green">125</span>
              <br /><br />
              <b><span class="fragment highlight-green">}</span></b>
            </p>

            <aside class="notes">
              * SÃ¥ fra chifferteksten vi har starter vi med "w" (NESTE)
              (NESTE)<br /><br />

              * w XOR med (4 minus "asteriks") (NESTE)<br /><br />

              * Dvs. med ASCII-tallverdier er w 119, 4 er 52 og asteriks er
              42.<br /><br />

              * SÃ¥ 119 XOR med (52 minus 42), gir oss:<br /><br />

              125 (NESTE x2), som nÃ¥r vi slÃ¥r opp i ASCII-tabellen er tegnet
              "hÃ¸yre-krÃ¸llparentes"
            </aside>
          </section>

          <section>
            <p>
              w*<span class="fragment highlight-green">4</span
              >*D*T*W*J*7*A*Y*f*`*j (...)
            </p>

            <p class="fragment">4 XOR (D-*)</p>

            <p class="fragment">
              ...med ASCII-tallverdier:<br />
              52 XOR (68-42) =
              <span class="fragment highlight-green">46</span>
              <br /><br />
              <b><span class="fragment highlight-green">.</span></b>
            </p>

            <aside class="notes">
              Vi har fÃ¸rste tegn i passordet! Vi prÃ¸ver algoritmen pÃ¥ neste tegn
              i chifferteksten som er 4 (NESTE):<br /><br />

              * 4 XOR med (D minus "asteriks") (NESTE)<br /><br />

              * Dvs. med ASCII-tallverdier er 4 52, D er 68 og asteriks er
              42.<br /><br />

              * SÃ¥ 52 XOR med (68 minus 42), gir oss:<br /><br />

              46 (NESTE x2), som nÃ¥r vi slÃ¥r opp i ASCII-tabellen er tegnet
              "punktum"
            </aside>
          </section>

          <section>
            <p>
              Vi hÃ¥ndregner oss fram til vi har et par bokstaver i passordet:
            </p>
            <p class="fragment highlight-green"><b>}.nywG</b></p>
            <br />
            <h3 class="fragment fade-up">ğŸ¤”</h3>

            <aside class="notes">
              Vi hÃ¥ndregner ut et par tegn til for Ã¥ sjekke om algoritmen
              faktisk stemmer, og fÃ¥r: (NESTE)<br />

              * krÃ¸llparentes fra w-tegnet <br />
              * punktum fra 4-tegnet<br />
              * nywG (NESTE)<br /><br />

              MÃ¥ innrÃ¸mme at det ser litt gresk ut, hadde hÃ¥pet pÃ¥ noe som
              lignet pÃ¥ passordet nÃ¥
            </aside>
          </section>

          <section>
            <p>
              Vi utvider
              <b>lÃ¸sning.py</b> med ny funksjon som bruker algoritmen vÃ¥r til Ã¥
              dekryptere resten av chifferteksten
            </p>

            <aside class="notes">
              Vi er pÃ¥ sporet av noe. Vi utvider programmet
              <b>lÃ¸sning.py</b> med en ny funksjon som bruker denne algoritmen
              vi har funnet, og dekrypterer resten av chifferteksten for oss
            </aside>
          </section>

          <section>
            <p>
              Lager en decipher()-funksjon for Ã¥ dekryptere chifferteksten i
              <b>lÃ¸sning.py</b>:
            </p>

            <pre>
              <code class="python smaller" data-trim data-noescape>
                deciphered_cipher_raw = decipher(text) # text="Passord: "w*4*D*T*W (...)"

                print(deciphered_cipher_raw)
              </code>
            </pre>

            og kjÃ¸rer programmet:

            <pre>
              <code class="python" data-trim data-noescape>
                $ python lÃ¸sning.py underfundig
              </code>
            </pre>

            <aside class="notes">
              Vi lager en <b>decipher</b>-funksjon i <b>lÃ¸sning.py</b> for Ã¥
              hente ut det vi hÃ¥per er dekrypterte flagget<br /><br />

              <b>dechipher</b>-funksjonen fÃ¥r chifferteksten som vi fant istad
              som input, og algoritmen vi har regnet oss frem til finner ett og
              ett passordtegn.<br /><br />

              Vi kjÃ¸rer <b>lÃ¸sning.py</b> og krysser fingrene!
            </aside>
          </section>

          <section>
            <h3>}.nywG neP .nywG re nvan ttiM{TSHP</h3>

            <p class="fragment fade-up">ğŸ˜²</p>

            <aside class="notes">
              Vi er sÃ¥ nÃ¦re! Men hva mÃ¥ vi gjÃ¸re her? (NESTE)<br /><br />

              Du ser at teksten her ikke er helt riktig.<br /><br />

              Stemmer, teksten er bakvendt! For Ã¥ fÃ¥ riktig flaggformat sÃ¥ mÃ¥
              reversere teksten
            </aside>
          </section>

          <section>
            <p>
              Vi snur om pÃ¥ rekkefÃ¸lgen pÃ¥ den dechiffrerte teksten i
              <b>lÃ¸sning.py</b>:
            </p>

            <pre>
              <code class="python" data-trim data-noescape>
              deciphered_cipher = deciphered_cipher_raw[::-1]

              print(deciphered_cipher)
              </code>
            </pre>

            og kjÃ¸rer programmet igjen:

            <pre>
              <code class="python" data-trim data-noescape>
              $ python lÃ¸sning.py underfundig
              </code>
            </pre>

            <aside class="notes">
              Vi justerer <b>lÃ¸sning.py</b> og snur om pÃ¥ rekkefÃ¸lgen i den
              dekrypterte teksten<br /><br />

              SÃ¥ kjÃ¸rer vi <b>lÃ¸sning.py</b> igjen
            </aside>
          </section>
          <section>
            <h3>PHST{Mitt navn er Gwyn. Pen Gwyn.}</h3>

            <img
              data-src="img/penguin-dancing-moves.gif"
              class="fragment fade-up plain"
              style="width: 40%"
            />

            <aside class="notes">
              Yes! <b>Der</b> har vi endelig flagget! <br /><br />

              Mitt navn er Gwyn. Pen Gwyn. (NESTE) (vent 3s)
            </aside>
          </section>

          <section>
            <p>Vi kjÃ¸rer <b>merkelig.py</b> igjen:</p>
            <pre class="shell">
              <span>$ python merkelig.py underfundig</span>              
              <span class="fragment">Passord: <span class="fragment highlight-green">PHST{Mitt navn er Gwyn. Pen Gwyn.}</span></span>
              <span class="fragment">Gratulerer! Flagget vet du allerede :)</span>                
            </pre>

            <p class="fragment fade-up">ğŸ˜</p>

            <aside class="notes">
              Da gjenstÃ¥r det Ã¥ verifisere at det faktisk ER passordet vi har
              funnet<br /><br />

              Vi kjÃ¸rer det opprinnelige programmet <b>merkelig.py</b> igjen og
              gir den det vi hÃ¥per er passordet (NESTE) (NESTE)<br /><br />

              Og vi fÃ¥r bekreftet: (NESTE)
              <b>Gratulerer! Flagget vet du allerede :)</b> (NESTE)<br /><br />

              Kult!
            </aside>
          </section>

          <section data-source="leo_reversing">
            <img
              data-src="img/leo_reversing.jpg"
              class="plain"
              style="width: 60%"
            />

            <aside class="notes">
              FÃ¸lelsen man har nÃ¥r man har kommet hit er ca slik! Vi i mÃ¥l! Bra
              jobba for Ã¥ holde ut helt hit. Jeg syns vi kan vÃ¦re litt stolte av
              Ã¥ ha dekompilert et emoji-program som kjÃ¸rte pÃ¥ en snedig variant
              av en stack-basert virtuell maskin skrevet i Python!<br /><br />

              Det var mye detektivarbeid for Ã¥ komme helt hit men med litt
              pÃ¥gangsmot, fokus, bruke tid pÃ¥ forstÃ¥ ett og ett delproblem av
              gangen, og lage oss verktÃ¸y som gir litt bedre oversikt, sÃ¥ fant
              vi riktig lÃ¸sning til slutt<br /><br />

              I CTF'er handler det ofte om Ã¥ rekke Ã¥ melde inn flaggene innen
              viss tid. Men jeg koste meg med dette. Brukte flere mÃ¥neder i
              kalendertid nÃ¥r jeg hadde lyst pÃ¥ pirke videre pÃ¥ oppgaven. LÃ¦rte
              ogsÃ¥ masse om stack-baserte programmer underveis.
            </aside>
          </section>
        </section>

        <!-- =================== OPPSUMMERING =================== -->
        <section>
          <section>
            <h2>GÃ¸y, ikke sant?</h2>

            <aside class="notes">
              Jeg hÃ¥per denne oppgaven vekket litt nysgjerrighet hos dere slik
              som den gjorde for meg<br /><br />

              Syns du det du sÃ¥ idag sÃ¥ litt gÃ¸y ut?
            </aside>
          </section>

          <section>
            <h3>Tenn din indre kodegnist! ğŸª„</h3>
            <p>
              <a href="https://p26e.dev">p26e.dev fra PST</a>
            </p>
            <p>
              <a
                href="https://www.kode24.no/artikkel/hjelp-tom-a-bekjempe-tombot-i-porsverse---bli-med-i-kode24s-julekalender/74768986"
                >Kodekalender fra Kode24</a
              >
            </p>
            <p>
              <a href="https://www.youtube.com/@GynvaelEN/streams"
                >YouTube: Gynvael</a
              >
            </p>
            <p>
              <a href="https://ctf.hacker101.com">Hacker101 CTF</a>
            </p>
            <p>
              <a href="https://cryptohack.org">cryptohack.org</a>
            </p>

            <aside class="notes">
              Jeg hÃ¥per dette tente din indre kodegnist. Vi blir bedre
              problemlÃ¸sere av Ã¥ Ã¸ve.<br /><br />

              PST, Kode24 med flere pleier Ã¥ legge ut CTF'er som adventskalender
              og pÃ¥skenÃ¸tter.<br /><br />

              LÃ¦r ved Ã¥ se andre lÃ¸se oppgaver. Jeg har lÃ¦rt masser av
              <b>Gynvael</b> pÃ¥ YouTube!<br /><br />

              PÃ¥ CTF-sidene til Hacker101 finner du mange nybegynneroppgaver du
              kan starte med<br /><br />

              Hvis du synes XOR og binÃ¦rmatematikk er spennende er
              cryptohack.org stedet for deg.<br /><br />

              PrÃ¸v deg pÃ¥ de enkle oppgavene. Kjenn litt pÃ¥ mestringsfÃ¸lelsen
              nÃ¥r du begynner Ã¥ finne flaggene. Jeg hÃ¥per dere ogsÃ¥ blir hekta!
            </aside>
          </section>
        </section>

        <!-- =================== TAKK =================== -->
        <section data-transition="concave">
          <h2>Takk!</h2>
          <br />
          <div class="columns">
            <div class="col">
              <div
                class="qrcode"
                align="center"
                title="https://henrikwm.github.io/p-sken-tteknekking_med_emojier"
              ></div>
              <div class="half-size"><a class="qrcode-link"></a></div>
            </div>
            <div class="col">
              <img
                src="img/oppsummering-takk2.png"
                class="plain"
                style="width: 50%"
              />
            </div>
          </div>
          <br />
          <p>
            <a href="mailto:henrik.walker.moe@bekk.no"
              >henrik.walker.moe@bekk.no</a
            >
          </p>

          <aside class="notes">
            * Alt av det dere har sett idag om oppgaven og lÃ¸sningen finner du
            pÃ¥ mitt GitHub-repo.<br /><br />

            * Tusen takk for at dere kom og hÃ¸rte pÃ¥!<br /><br />

            * Takk for meg!
          </aside>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>

    <!-- Reveal-listeners -->
    <script type="text/javascript" async defer>
      // Sources
      var sources = {
        background_image: "Foto: iStock.com, rami_hakala",
        bitmoji: "Bitmoji Avatar â’¸ Snap Group Limited",
        henrikwm: "Kilde: Henrik Walker Moe, Lisens: CC BY 4.0",
        stegsolve_caesum: "Foto: StegSolve, Caesum, Windows 10",
        failOverflow_doge_stege:
          "Kilde: https://fail0verflow.com/blog/2014/plaidctf2014-for100-doge_stege/, Foto: jix, fail0verflow",
        leo_reversing: "Kilde: https://imgflip.com/i/4edng0",
        stack_machine: "Kilde: https://en.wikipedia.org/wiki/Stack_machine",
        wiki_callstack:
          "Kilde: https://commons.wikimedia.org/wiki/File:Call_stack_layout.svg",
      };

      function setFooterSource() {
        var currentSlide = Reveal.getCurrentSlide();

        var footer = document.getElementById("title-footer");
        if (footer) {
          footer.parentNode.removeChild(footer);
        }

        var source = currentSlide.getAttribute("data-source");
        if (source !== null) {
          title_footer.initialize(sources[source]);
        }
      }

      Reveal.addEventListener("ready", function (event) {
        setFooterSource();
      });

      Reveal.addEventListener(
        "slidechanged",
        function () {
          setFooterSource();
        },
        false
      );
    </script>

    <!-- QR Codes -->
    <script type="text/javascript">
      // Get presentation URL
      var qrcode_url =
        "https://henrikwm.github.io/p-sken-tteknekking_med_emojier";

      // Generate QR Codes : class="qrcode"
      var qrcode_elements = document.getElementsByClassName("qrcode");
      for (var i = 0; i < qrcode_elements.length; i++) {
        var qrcode_el = qrcode_elements[i];

        var qrcode = new QRCode(qrcode_el, {
          text: qrcode_url,
          width: 250,
          height: 250,
        });

        // Alter generated image
        var img_el = qrcode._el.childNodes[1];
        img_el.classList.add("plain"); // remove border
      }

      // Add text to links : class="qrcode-link"
      var qrcode_link_elements = document.getElementsByClassName("qrcode-link");
      for (var i = 0; i < qrcode_link_elements.length; i++) {
        var link_el = qrcode_link_elements[i];
        link_el.textContent = qrcode_url;
        link_el.href = qrcode_url;
      }
    </script>

    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        controls: true,
        progress: true,
        center: true,
        hash: true,
        history: true,

        navigationMode: "linear",

        transition: "slide", // none/fade/slide/convex/concave/zoom

        parallaxBackgroundImage: "img/background_bond.png",
        parallaxBackgroundSize: "3700px 1600px",

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
        dependencies: [
          {
            src: "plugin/markdown/markdown.js",
            condition: function () {
              return !!document.querySelector("[data-markdown]");
            },
          },

          // Syntax highlight for <code> elements
          { src: "plugin/highlight/highlight.js", async: true },

          { src: "plugin/search/search.js", async: true },

          // Speaker notes
          { src: "plugin/notes/notes.js", async: true },

          // Zoom in and out with Alt+click
          { src: "plugin/zoom-js/zoom.js", async: true },

          // Title-Footer plugin
          { src: "plugin/title-footer/title-footer.js" },
        ],
      });
    </script>
  </body>
</html>
