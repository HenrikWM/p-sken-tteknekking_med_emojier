<!DOCTYPE html>
<html lang="nb">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <title>Påskenøtteknekking med emojier 🐇 - Pangea 2020</title>

    <meta
      name="description"
      content="Påskenøtteknekking med emojier 🐇 - Pangea 2020"
    />
    <meta name="author" content="Henrik Walker Moe" />

    <meta
      name="viewport"
      content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <meta
      property="og:title"
      content="Påskenøtteknekking med emojier 🐇 - Pangea 2020"
    />
    <meta
      property="og:description"
      content="En gjennomgang av løsningen på PST-gåten presentert på JavaZone/Bekk fagdag 2019"
    />
    <meta property="og:site_name" content="Github" />
    <meta
      property="og:image"
      content="https://henrikwm.github.io/p-sken-tteknekking_med_emojier/img/paskekyllingbetjenter.png"
    />
    <meta property="og:type" content="article" />
    <meta
      property="og:url"
      content="https://henrikwm.github.io/p-sken-tteknekking_med_emojier"
    />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@github" />
    <meta name="twitter:creator" content="@henrikwm" />
    <meta
      name="twitter:title"
      content="Påskenøtteknekking med emojier 🐇 - Pangea 2020"
    />
    <meta
      name="twitter:description"
      content="En gjennomgang av oppgaven 'Andre påskedag' fra PSTs påske-CTF 2020"
    />
    <meta
      name="twitter:image"
      content="https://henrikwm.github.io/p-sken-tteknekking_med_emojier/img/paskekyllingbetjenter.png"
    />

    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="msapplication-tap-highlight" content="no" />

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/black.css" id="theme" />
    <link rel="stylesheet" href="dist/custom.css" />

    <!-- Theme used for syntax highlighted code -->
    <link
      rel="stylesheet"
      href="plugin/highlight/zenburn.css"
      id="highlight-theme"
    />

    <!-- Title-Footer plugin -->
    <link rel="stylesheet" href="plugin/title-footer/title-footer.css" />
    <link rel="stylesheet" href="plugin/title-footer/title-footer-custom.css" />

    <!-- QR Codes -->
    <script type="text/javascript" src="lib/qrcode.min.js"></script>

    <!-- Globals -->
    <script type="text/javascript">
      var defaultFooterText =
        "Påskenøtteknekking med emojier 🐇 - Pangea 2020";
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- =================== START =================== -->
        <section>
          <!-- <section data-source="background_image">
            <p>
              <span class="fragment">henrikwm</span>
              <span class="fragment">@</span>
              <span class="fragment">bekk</span>
            </p>
            <aside class="notes">
              Hei! Mitt navn er (NESTE) Henrik Walker Moe og jeg er fagleder for
              (NESTE) (NESTE) Sikkerhet i Bekk<br /><br />

              Og idag skal jeg snakke om...
            </aside>
          </section> -->

          <section data-source="bitmoji">
            <div>
              <h2>Påskenøtteknekking med emojier 🐇</h2>
              <img src="img/intro_spy_avatar.png" class="plain" />
            </div>
            <aside class="notes">
              Hei! Mitt navn er Henrik Walker Moe og jeg er fagleder for
              Sikkerhet i Bekk<br /><br />

              Idag skal vi sammen løse en oppgave fra årets påskenøtter fra
              PST<br /><br />

              PST har i de siste årene lagt ut en Capture The Flag (CTF)
              konkurranse i påsken. I en CTF-oppgave handler det om å løse flere
              deloppgaver til man til slutt finner en skjult kode, også kalt et
              "flagg"
            </aside>
          </section>
        </section>

        <!-- =================== OM MEG ===================
        <section>
          <section>
            <h2>Hvem er jeg?</h2>
            <aside class="notes">Et par ord om meg</aside>
          </section>

          <section
            data-background="img/intro_henrik_ecotrail.JPG"
            data-source="henrikwm"
          >
            <aside class="notes">
              Jeg...<br />
              * liker å løpe, noen ganger langt. Her fra Ecotrail i mai ifjor<br />
              * er sta, har pågangsmot <br />
              * liker utfordringer med klare mål<br /><br />

              Alle disse egenskapene viser det seg, egner seg ikke bare til å
              holde ut i 5 mil i skogen på Ecotrail, de egner seg også veldig
              godt til kodeknekking
            </aside>
          </section>

          <section>
            <h3>I ❤️ CTF-er</h3>
            <aside class="notes">
              Og som nevnt, jeg digger Capture the Flag oppgaver!<br />

              * Hvorfor liker jeg CTF'er? <br />
              ** <b>Prosessen</b>: <b>rekognosering</b> og <b>analyse</b> for å
              forstå hvordan man kan <b>utnytte</b> en sårbarhet<br />
              ** <b>Måldrevne</b>: delmål underveis, motiverer<br />
              ** <b>Belønning!</b>: (flagget, viktig spisskompetanse)<br /><br />

              På mange måter er CTF'er sikkerhetsbransjens e-sport og det gjør
              kompetansebygging både gøy og motiverende når neste mestring er et
              flagg unna.
            </aside>
          </section>

          <section>
            <h3>Sikkerhetsfaggruppen ❤️ CTF-er</h3>
            <aside class="notes">
              Vi i Sikkerhetsfaggruppen i Bekk bruker CTF'er aktivt til
              kompetansebygging. Både fordi CTF'er ofte er pedagogisk bra lagt
              opp men også fordi de er så motiverende å jobbe med når du endelig
              finner det flagget du har slitt lenge med å finne!<br /><br />

              Idag skal vi sammen kjenne litt på den gleden.
            </aside>
          </section> -->

        <!-- =================== OPPGAVEN =================== -->
        <section>
          <section>
            <h2>"Andre påskedag"</h2>

            <aside class="notes">
              Og oppgaven jeg har tenkt å vise dere heter "Andre påskedag"
              <br /><br />

              Grunnen til at jeg ønsker å vise dere akkurat denne oppgaven er
              fordi ikke bare var den morsom, den utfordrer deg også på viktige
              egenskaper man trenger som problemløser og kodeknekker:<br /><br />

              * analytisk <br />
              * bryte ned problemet<br />
              * kunne verktøyene<br />
              * forstå fagteorien bak problemstillingen vi må løse<br /><br />

              Så er det jo også en haug med emojis her som jo er litt spennende!
            </aside>
          </section>

          <section>
            <h3>Vi har fått 3 filer</h3>
            <ul>
              <li>
                <a href="ctf.phst.no/andre_påskedag/img/paskekyllingbetjenter.png"
                  >paskekyllingbetjenter.png</a
                >
              </li>
              <li>
                <a href="ctf.phst.no/andre_påskedag/merkelig.py">merkelig.py</a>
              </li>
              <li>
                <a href="ctf.phst.no/andre_påskedag/underfundig">underfundig</a>
              </li>
            </ul>
            <aside class="notes">
              Oppgaven gir oss disse 3 filene:<br /><br />

              * påskekyllingbetjenter.png<br />
              * merkelig.py<br />
              * underfundig<br /><br />

              Det første vi må gjøre er å analysere det vi har fått og prøve å
              forstå problemstillingen.
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h2>Analyse</h2>
          </section>
          <section>
            <h3>paskekyllingbetjenter.png</h3>
            <img
              data-src="img/paskekyllingbetjenter.png"
              class="plain"
              style="width: 90%"
            />
            <aside class="notes">
              Vi begynner med bilde av påskekyllingbetjentene.<br /><br />

              For å lete etter ledetråder i bilder liker jeg å bruke programmene
              <b>file</b> og <b>strings</b> på Linux. Ofte finner man skjult
              tekst i bilder og disse programmene vil finne det<br /><br />

              Dessverre var det ingen skjult tekst i bildet.<br /><br />

              Så neste analyse jeg tenker er lurt da:
              <b>Steganografi</b>-analyse!
            </aside>
          </section>

          <section>
            <img
              data-src="img/paskekyllingbetjenter_stegsolve.gif"
              class="plain"
              style="width: 100%"
            />
            <aside class="notes">
              (Forklar Steganografi)<br /><br />

              Her bruker jeg <b>Stegsolve</b>: et program som lar oss bla
              igjennom bildefiltre for å se etter skjult tekst i bilder
              <br /><br />

              Men vi finner ingenting her heller.<br /><br />

              Konklusjon: dette er bare lokkemat og vi legger bildet til side
            </aside>
          </section>

          <section>
            <h3>underfundig</h3>
            <img
              data-src="img/underfundig_emojis.png"
              class="plain"
              style="width: 100%"
            />
            <aside class="notes">
              Her har vi 1043 emojier på rad og rekke! (stablet de sammen
              her)<br /><br />

              Tydeligvis noe mening med dette. Vi ser noen emojier repeteres,
              noen bare forekommer en gang. Hva er de vi har her som er enkodet
              som emojier? <br /><br />

              Ellers er ikke så mye mer å finne ut her, så vi ser på siste fil.
            </aside>
          </section>

          <section>
            <h3>merkelig.py</h3>
            <p>Vi tester ut programmet:</p>
            <pre><code class="python" data-trim data-noescape>
              python .\merkelig.py .\underfundig
              Passord:
            </code></pre>
            <aside class="notes">
              <b>merkelig.py</b> er et Python-skript. Når vi kjører skriptet så
              spør det etter et passord
            </aside>
          </section>

          <section>
            <p>Spurt om et passod, angir et tilfeldig passord <b>123456</b>:</p>
            <pre><code class="shell" data-trim data-noescape>
              python .\merkelig.py .\underfundig
              Passord: 123456
              Ikke riktig :(
            </code></pre>
            <p>åpenbart feil passord :(</p>
            <p class="fragment fade-up">Må finne passordet!</p>
            <br />
            <h3 class="fragment fade-up">🤔</h3>
            <aside class="notes">
              Og alle forsøk på å gjette passordet blir feil (NESTE x2)<br /><br />

              Tydeligvis er målet er å finne passordet<br /><br />

              Så vi må begynne å lete litt mer grundig...
            </aside>
          </section>

          <section data-transition="none">
            <h3>merkelig.py</h3>
            <img
              data-src="img/merkelig_py_1.png"
              class="plain"
              style="width: 70%"
            />
            <aside class="notes">
              Vi studerer Pyton-skriptet litt nærmere
            </aside>
          </section>

          <section data-transition="none">
            <h3>merkelig.py</h3>
            <img
              data-src="img/merkelig_py_1_highlighted.png"
              class="plain"
              style="width: 70%"
            />
            <aside class="notes">
              * Vi ser enkelte emojier defineres med en tall-verdi <br />
              * Vi ser en funksjon <b>parse_num</b> som gjør om input til et
              tall
              <br />
              * Vi ser at <b>underfundig</b>-filen med alle emojiene kreves som
              input for å kjøre<br />
              * Vi ser en "stack" bli definert som et 256-plasser stort
              register<br /><br />

              Vi legger merke til variabelnavnene: <b>pc</b>, <b>stack</b> og
              <b>sp</b>
            </aside>
          </section>

          <section data-transition="none">
            <h3>merkelig.py</h3>
            <img
              data-src="img/merkelig_py_2.png"
              class="plain"
              style="width: 70%"
            />
            <aside class="notes">
              Hmm. Videre ned i skriptet ser vi at dette kjøres i en
              while-løkke
            </aside>
          </section>

          <section data-transition="none">
            <h3>merkelig.py</h3>
            <img
              data-src="img/merkelig_py_2_highlighted.png"
              class="plain"
              style="width: 70%"
            />
            <aside class="notes">
              Og når vi ser hva <b>op</b>, <b>pc</b>, <b>sp</b>, <b>stack</b> osv. brukes
              til i hver runde i while-løkken, og spesielt i hver av operand-emojiene, så begynner dette å bli klart hva vi
              har med å gjøre.
            </aside>
          </section>
        </section>

        <!-- =================== STACK-BASERT VIRTUELL MASKIN =================== -->
        <section>
          <section>
            <h2>Stack-basert virtuell maskin</h2>
            <aside class="notes">En "Stack-basert virtuell maskin"</aside>
          </section>

          <section data-source="stack_machine">
            <p>Fra Wikipedia:</p>
            <blockquote>
              A "stack machine" is a computer that uses a last-in, first-out
              stack to hold short-lived temporary values. Most of its
              instructions assume that operands will be from the stack, and
              results placed in the stack.
            </blockquote>
            <aside class="notes">
              <b>merkelig.py</b>-skriptet er den virtuelle maskinen og
              <b>underfundig</b>-filen med emojier er programmet den kjører:<br /><br />
              <!--
              * lese input fra bruker<br />
              * hoppe til neste instruks<br />
              * lagre data i minnet osv.<br />

              Og stacken brukes til å holde på data som den virtuelle maskinen
              har i "minnet" når programmet kjører -->
            </aside>
          </section>

          <section>
            <p>Hva kjennetegner en stack-basert virtuell maskin?</p>
            <ul class="fragment">
              <li>
                <span class="fragment highlight-green">pc</span>: program
                counter (programteller)
              </li>
              <li>
                <span class="fragment highlight-green">stack</span>: register
                med programmets data
              </li>
              <li>
                <span class="fragment highlight-green">sp</span>: stack pointer
                (peker på gjeldende posisjon i stacken)
              </li>
              <li>
                <span class="fragment highlight-green">op</span>: operand
                (<b>pop</b>, <b>push</b>, <b>jmp</b>, <b>xor</b> osv.)
              </li>
            </ul>
            <aside class="notes">
              Kjennetegnene til en stack-basert virtuell maskin er:
              (NESTE)(NESTE)<br /><br />

              * PC (program counter) er programtelleren, også kalt instruksjonspeker, som holder
              styr på rekkefølgen av instruksjoner som kjøres (NESTE)<br />

              * STACKen er registeret hos den virtuelle maskinen som tar vare på
              programmets data (NESTE)<br />

              * SP (stack-pointer) er gjeldende posisjonen i STACKen, så programmet vet hvor i
              STACK-registeret den kan finne neste data eller instruksjon å
              jobbe med (NESTE)<br />

              * OP er operanden (instruksjonen) som programmet ønsker at
              maskinen skal utføre
            </aside>
          </section>

          <section>
            <p>
              Alle operand-emojiene underfundig-filen inneholder...<br/>
              <br/>
              🐰🐥🌱🌻🐇🥚🐤🐣🌞
              <br/>
            </p>
            <p class="fragment">er <span class="fragment highlight-green">maskininstruksjoner</span>!</p>
            <aside class="notes">
              Så alle operandene vi ser i underfundig-filen er alstå da (NESTE x2)...<br/><br/>
              maskininstruksjoner til et program!
            </aside>
          </section>

          <section>
            <pre class="even-less-spacing"><code class="python smallester" data-trim data-noescape>
              (...)
              elif op == "🐥": # 1. kylling tilsvarer assembly-instruksjonen "PUSH"
                  stack[sp] = stack[sp-1]
                  sp += 1
              elif op == "🌱": # 2. frø tilsvarer assembly-instruksjonen "ADD"
                  sp -= 1
                  stack[sp-1] += stack[sp]
                  stack[sp-1] %= base**4
              elif op == "🌻": # 3. solsikke tilsvarer assembly-instruksjonen "SUB"
                  sp -= 1
                  stack[sp-1] -= stack[sp]
                  stack[sp-1] %= base**4
              elif op == "🐇": # 4. kanin tilsvarer assembly-instruksjonen "JMP"
                  sp -= 1
                  if stack[sp] != 0:
                      pc += parse_num(code[pc:pc+4])
                  else:
                      pc += 4
              (...)
            </code></pre>
            <aside class="notes">
              Vi kjenner igjen maskininstruksjonene i denne virtuelle maskinen, som jo ligner litt på kjente instruksjoner fra assembly-språk (det datamaskiner bruker til instruksjoner):<br/>

              * Pkt.1: kylling flytter gjeldende stack-verdi i stacken en plass ned i stack-registeret, en "push"<br/>
              * Pkt.2: spire gjør blant annet addering mellom to stack-verdier, en "add"<br/>
              * Pkt.3: solsikke gjør blant annet subtraksjon mellom to stack-verdier, en "sub"<br/>
              * Pkt.4: ...og kaninen hopper til ny instruksjon eller videre i programmet, en "jump"<br/><br/>

              Så når vi mapper alle operandene i hele denne virtuelle maskinen til noe som ligner på mer kjente maskininstruksjoner...
            </aside>
          </section>

          <section>
            <p>
              Operander og maskininstrukser i den virtuelle maskinen:
            </p>
            <table>
              <thead>
                <tr>
                  <th>Emoji-operand</th>
                  <th>Tilsvarer instruksjon</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>🐇</td>
                  <td>jmp</td>
                </tr>
                <tr>
                  <td>🐥</td>
                  <td>push</td>
                </tr>
                <tr>
                  <td>🌻</td>
                  <td>pop_sub</td>
                </tr>
                <tr>
                  <td>🌱</td>
                  <td>pop_add</td>
                </tr>
                <tr>
                  <td>🥚</td>
                  <td>xor (⊕)</td>
                </tr>
                <tr>
                  <td>...</td>
                  <td>...</td>
                </tr>
              </tbody>
            </table>
            <aside class="notes">
              Så får vi dette! Har man erfaring med assembly-språk og lavnivå programmering så
              kjenner man igjen hva alle disse operandene i vår virtuelle maskin tilsvarer:<br /><br />

              * operanden kanin "hopper" (jump)<br />
              * kylling er "push" <br />
              * solsikke er "pop" og "sub"<br />
              * spire er "pop" og "add"<br />
              * egg er XOR (en maskininstruks som regner på to faktorer). XOR
              ofte brukt i forbindelse med kryptering... interessant!<br /><br />

              Nå vet vi at <b>underfundig</b>-filen er et program og at en
              del av emojiene er maskininstruksjoner!
            </aside>
          </section>

          <section>
            <p>
              underfundig er et program som er
              <span class="fragment highlight-green">kompilert</span> til
              emojier
            </p>
            <p class="fragment">
              kan vi <span class="fragment highlight-green">dekompilere</span>
              programmet tilbake til menneskelesbar kildekode?
            </p>
            <aside class="notes">
              Når man lager programmer så kompilerer (NESTE) man kildekoden med
              en kompilator, som omgjør menneskelesbar kildekode til lavnivå
              maskininstrukser som maskinens kan forstå og kjøre<br /><br />

              underfundig kan man si er "kompilert" til emojier slik at den kan
              kjøres på denne virtuelle maskinen i
              <b>merkelig.py</b> (NESTE)<br /><br />

              Hvis vi kan reversere (NESTE) det kompilerte programmet tilbake
              til menneskelesbar kildekode, så kan vi kanskje forstå hva
              programmet gjør og finne det passordet vi er på jakt etter
            </aside>
          </section>
        </section>

        <!-- =================== DEKOMPILERING =================== -->
        <section>
          <section>
            <h2>Dekompilering</h2>
          </section>

          <section>
            <p>
              For å lage et dekompileringsskript må vi forstå
              underfundig-programmet litt bedre
            </p>
            <aside class="notes">
              Vi lærte at underfundig-programmet inneholder operander, men for å
              dekompilere hele programmet må vi også vite hva resten av emojiene
              er.
            </aside>
          </section>

          <section>
            <p>Finner vi et mønster i emojiene?</p>
            <div class="fragment fade-up">
              <p>🐰🎮🍫🎮🎲🐤🐰🍫🎨🎮🎲🐤🐰🍫🍫🎧🎲🐤</p>
              <p>-</p>
            </div>

            <div class="fragment fade-up">
              <p>🐰🐥🌱🌻🐇🥚🐤🐣🌞</p>
              <p>=</p>
            </div>

            <div class="fragment fade-up">
              <p>🎮🍫🎮🎲🍫🎨🎮🎲🍫🍫🎧🎲</p>
            </div>
            <aside class="notes">
              Kanskje kan vi finne et mønster i underfundig-emojiene? (NESTE)
              <br /><br />

              * Dette er de første emojiene i underfundig-filen...(NESTE)<br />
              * Hvis vi trekker fra de operand-emojiene som vi vet er
              maskininstruksjoner (NESTE)<br />
              * Hva sitter vi igjen med da?<br /><br />

              Kan dette være data som programmet bruker på noen måte (bokstaver
              og tall)?
            </aside>
          </section>

          <section>
            <p>
              Vi vet hva som er operander: <br />
              🐰🐥🌱🌻🐇🥚🐤🐣🌞
            </p>
            <br />
            <p>I <b>merkelig.py</b> så vi:</p>
            <pre><code class="python" data-trim data-noescape>
              digits = {"🎲": 0, "🍫": 1,  "🎮": 2, "🎧": 3, "🎨": 4, "🍬": 5}
            </code></pre>
            <br />
            <p>Så vi vet at disse er data: <br />🎲🍫🎮🎧🎨🍬</p>
            <aside class="notes">
              Vi vet nå hvilke emojier som er operander og hvilke som er data.
              Nå har vi det vi trenger for å dekompilere programmet
            </aside>
          </section>

          <section>
            <p>
              Vi lager et Python-skript som dekompilererer emojiene til
              "pseudo-kode"
            </p>
            <pre><code class="shell" data-trim data-noescape>
              python .\underfundig_dekompilering.py .\underfundig
            </code></pre>
            <aside class="notes">
              Vi lager skriptet <b>underfundig_dekompilering.py</b> som
              oversetter emojiene i underfundig-programmet til operander og
              data. Forhåpentligvis er resultatet noe som gjør at vi kan lettere
              forstå hva programmet gjør
            </aside>
          </section>

          <section>
            <img
              data-src="img/underfundig_dekompilert.png"
              class="plain"
              style="width: 30%"
            />
            <aside class="notes">
              Og da får vi dette! Programmet har skrevet ut linje for linje alle
              operandene og emoji-dataene
              <br /><br />

              * Øverst på steg 0 i programmet: Hare leser inn de neste 4
              emojiene fra STACK'en<br />

              * De 4 emojiene er data (tallverdi 80, 80 i ASCII-tabellen er
              bokstaven "P"). ASCII-tabellen er en liste over alle tegn på
              tastaturet ditt, hvor hver tegn har en tallverdi<br />

              * På steg 5 i programtelleren: Kylling skriver "P" ut til
              terminalen min <br /><br />

              Så vi klarer nå å lese at det første programmet gjør er å skrive
              ut "Passord:" til terminalen min, slik vi så det gjorde tidligere
              da jeg testet å kjøre "merkelig.py" og ikke hadde oppgitt riktig
              passord
            </aside>
          </section>

          <section>
            <p>I <b>merkelig.py</b> så vi:</p>
            <pre><code class="python" data-trim data-noescape>
              if op == "🐰":
                stack[sp] = parse_num(code[pc:pc+4]) # les inn 4 emojier
                sp += 1
                pc += 4
            </code></pre>
            <p>🐰 leser 4 emojier av gangen og omgjør til et tall</p>
            <aside class="notes">
              Vi har forstått at hare-operanden i den virtuelle maskinen vår
              leser inn 4 tegn av gangen<br /><br />

              Og tilbake fra "parse_num"-funksjonen får vi et tall...<br /><br />

              Hva slags tall er disse 4 og 4 data-emojiene tro?
            </aside>
          </section>

          <section>
            <p>Data-emojiene ser ut til å være tekst!</p>
            <table>
              <tr>
                <td></td>
                <td>🎮🍫🎮🎲</td>
                <td>🍫🎨🎮🎲</td>
                <td>🍫🍫🎧🎲</td>
                <td>🍫🍫🎧🎲</td>
              </tr>
              <tr>
                <td>ASCII-tallverdi</td>
                <td>80</td>
                <td>97</td>
                <td>115</td>
                <td>115</td>
              </tr>
              <tr>
                <td>Bokstav</td>
                <td>P</td>
                <td>a</td>
                <td>s</td>
                <td>s</td>
              </tr>
            </table>
            <aside class="notes">
              Vi har oppdaget at <b>underfundig</b>-programmet inneholder tekst!
              Her ser vi at rekkefølgen på data-emojiene gir oss "Pass", som vi
              antar er "Passord"...<br /><br />

              Kan vi lage et Python-skript som skriver ut all den skjulte
              teksten i hele
              <b>underfundig</b>-programmet tro?
            </aside>
          </section>

          <section>
            <p>
              Vi lager et nytt skript <b>løsning.py</b> som henter ut alle
              bokstavene i underfundig-programmet:
            </p>
            <pre><code class="python" data-trim data-noescape>
              text = extract_text(underfundig_content)

              print(text)
              </code></pre>
            og kjører skriptet:
            <pre><code class="shell" data-trim data-noescape>
              python .\løsning.py .\underfundig
              </code>
            </pre>
            <aside class="notes">
              Vi lager oss et nytt skript "løsning.py" som: <br />

              * oversetter alle data-emojiene til tallverdier * og så gjør vi om
              disse ASCII-tallverdiene ASCII-tegn slik at bokstavtallene blir
              til bokstaver<br /><br />

              Vi kaller kjører skriptet med underfundig-filen som input
            </aside>
          </section>
          <section>
            <h3>
              Passord:
              "w*4*D*T*W*J*7*A*Y*f*`*j*n***}*4*\x9d*ç*¿*Ą*Ŏ*Ŋ*Ŧ*ı*Ɖ*Ǔ*Ǒ*Ǐ*ǐ*Ǉ*Ǧ*ǜ*ƹ*ț*ɵGratulerer!
              Flagget vet du allerede :)\nIkke riktig :(\n
            </h3>
            <aside class="notes">
              Dette er spennende! Vi ser vi all teksten som programmet
              inneholder!<br /><br />

              Vi kjenner igjen noe av teksten:<br />
              * 'Passord: ' er det programmet printer ut når den vil ha
              passordet<br />
              * så har vi et hermetegn * og så mange kryptiske tegn i ca.
              strukturert form (annenhver tegn og stjerne)<br />
              * 'Gratulerer' og 'Ikke riktig'-teksten er teksten programmet gir
              oss ved galt eller riktig passord
              <br /><br />

              Siden vi vet at den lesbare teksten her er det programmet selv
              printer ut, er jeg veldig interessert i den
              <b>ikke-lesbare teksten her</b> som jeg sterkt mistenker er den
              krypterte chifferteksten (flagget) vi er ute etter!
            </aside>
          </section>
          <section>
            <p>w*4*D*T*W*J*7*A*Y*f*`*j*n***}*4*</p>
            <p>\x9d*ç*¿*Ą*Ŏ*Ŋ*Ŧ*ı*Ɖ*Ǔ*Ǒ*Ǐ*ǐ*Ǉ*Ǧ*ǜ*ƹ*ț*ɵ</p>
            <br />
            <h3 class="fragment fade-up">🕵️‍♀️🕵️‍♂️</h3>
            <aside class="notes">
              Dvs. dette er chifferteksten og vår neste utfordring (NESTE)<br /><br />

              Vi trenger å forstå hvordan chifferteksten har blitt kryptert slik
              at vi kan dekryptere den
            </aside>
          </section>
        </section>

        <!-- =================== DEKRYPTERING =================== -->
        <section>
          <section>
            <h2>Dekryptering</h2>
          </section>

          <section>
            <p>
              Målet vårt nå er å dekryptere chifferteksten til noe som matcher
              flaggformatet "PHST{...}"
            </p>
            <aside class="notes">
              Målet vårt nå er å se om vi kan dekryptere chifferteksten til noe
              som matcher flaggformatet som CTF-oppgaven forventer: PHST{...}
            </aside>
          </section>

          <section>
            <p>
              Vi endrer litt på <b>merkelig.py</b>: for hver operand som kjøres
              så printer vi ut hele stacken
            </p>
            <p>Da ser vi det samme som maskinen ser når programmet kjøres</p>
            <pre><code class="shell" data-trim data-noescape>
              python .\merkelig.py .\underfundig
              Passord: tulleinput
            </code></pre>
            <aside class="notes">
              Jeg er interessert i XOR-operanden vi så underfundig-programmet
              brukte tidligere. Jeg mistenker den brukes til kryptering men jeg
              må ha full oversikt over alt som skjer og dataverdier i stacken
              når underfundig-programmet kjøres, for å forstå nøyaktig hva som
              skjer<br /><br />

              Så vi tilpasser merkelig.py slik at vi ser det samme maskinen ser
              når underfundig-programmet kjøres<br /><br />

              Vi kjører Python-skriptet igjen med et tullepassord slik at vår
              oversikt kan genereres
            </aside>
          </section>

          <section>
            <p>Passord <b>tulleinput</b> gir denne stacken:</p>
            <pre><code class="shell" data-trim data-noescape>
            (...)

                t , u , l , l , e , i , n , p , u , t
            🐣:116,117,108,108,101,105,110,112,117,116,(10) (...)
            🐣:116,117,108,108,101,105,110,112,117,116,10,(0) (...)
            🐰:116,117,108,108,101,105,110,112,117,116,10,(34) (...)
            🐰:116,117,108,108,101,105,110,112,117,116,10,34,(0) (...)
            🌻:116,117,108,108,101,105,110,112,117,116,10,(34) (...)
            🌻:116,117,108,108,101,105,110,112,117,116,<span class="fragment highlight-green">-24</span>,(34) (...)
            🌻:116,117,108,108,101,105,110,112,117,116,1272,(34) (...)
            🐇:116,117,108,108,101,105,110,112,117,116,<span class="fragment highlight-green">(1272)</span>,34 (...)
            🐰:116,117,108,108,101,105,110,112,117,116,<span class="fragment highlight-green">(73)</span>,34 (...)

            (...)
            </code></pre>
            <p>
              Alle forsøk med gale passord ender med et negativt tallverdi på
              stacken som visst gjør at programmeta alltid spoler til "Ikke
              riktig :("
            </p>
            <aside class="notes">
              Så denne stacken, som er et 256-plasser stort register, er her
              skrevet ut bortover mot høyre med 256 plasser med data. Stacken er
              en "Last in, first out"-stack som betyr at plassen som er lengst
              mot høyre er dataverdien som er sist lagt på stacken<br />

              Her har underfundig-programmet har blitt kjørt og vi ser at
              maskinen har lest passordet vårt "tulleinput" inn i på stacken som
              ASCII-tallverdier<br />

              (NESTE x3) Siste linje med (73) er I, som i "Ikke riktig :(" -
              beskjeden vi får ved galt passord. Resten av stacken viser at
              programmet skriver ut denne beskjeden til min terminal.
            </aside>
          </section>

          <section>
            <p>
              Etter mange forsøk ulike passord med ulike lengder, og observasjon
              av forandringer i stacken...
            </p>
            <p class="fragment">Hvis passordet er 34 tegn langt...</p>
            <aside class="notes">
              Etter mye prøving og observasjon av stacken... (NESTE)<br />
              hvis jeg testet et passord som var 34 tegn langt...
            </aside>
          </section>

          <section>
            <p>Passord <b>tulleinput123456789123456789123456</b> gir:</p>
            <pre><code class="shell smaller" data-trim data-noescape>
            (...)     9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6
            🌻:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,0,<span class="fragment highlight-green">(34)</span> (...)
            🐇:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,(0),34 (...)
            🐰:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,(119),34 (...)
            🐰:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,119,(34) (...)
            🥚:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,(119),34 (...)
            🥚:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,65,(119),34 (...)
            🐰:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,65,(42),34 (...)
            🐰:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,65,42,(34) (...)
            (...)
            </code></pre>
            <p class="fragment">
              34 er der igjen! Passordet mitt er 34 tegn langt. Er det en
              passordlengdesjekk?
            </p>
            <p class="fragment">
              Og programmet kjørte litt lenger nå, vi har kommet til 🥚 (XOR)
            </p>
            <aside class="notes">
              (NESTE) 34 er der igjen! Passordet mitt er 34 tegn langt (NESTE)
              <br /><br />

              Er det en passordlengdesjekk? (NESTE)<br /><br />

              Programmet kjørte visst litt flere instrukser nå og vi ser egget
              (XOR) blir brukt!
            </aside>
          </section>

          <section>
            <p>
              ASCII-tegnet til tallet <b>34</b> er
              <span class="fragment highlight-green">"</span> (hermetegn)
            </p>
            <p>
              I teksten vi fant i underfundig-programmet: <br />
              <span class="fragment highlight-green"
                >Passord: "w*4*D*T*W(...)</span
              ><br />
              finner vi <b>"</b>
            </p>
            <p>Vi har funnet programmets hardkodede passordlengde! 😁</p>
            <aside class="notes">
              34 som ASCII-tegn er et hermetegn (NESTE) <br />
              Og vi så at i teksten vi fant var hermetegn (NESTE) foran rekken
              av tegn som hadde en viss struktur over seg.<br /><br />

              Vi ser ut til å ha funnet programmets konstant for passordlengde!
            </aside>
          </section>

          <section>
            <p>Passord <b>tulleinput123456789123456789123456</b>:</p>
            <pre><code class="shell smaller" data-trim data-noescape>
              (...)     9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6
              🌻:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,0,(34) (...)
              🐇:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,<span class="fragment highlight-green">(0)</span>,34 (...)
              🐰:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,(119),34 (...)
              🐰:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,54,119,(34) (...)
              🥚:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,<span class="fragment highlight-green">54,(119)</span>,34 (...)
              🥚:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,<span class="fragment highlight-green">65</span>,(119),34 (...)
              🐰:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,65,(42),34 (...)
              🐰:(...) 57,49,50,51,52,53,54,55,56,57,49,50,51,52,53,65,42,(34) (...)
              (...)
            </code></pre>
            <p>
              Hvis gjeldende stack-verdi er "0" når 🐇 operanden kjøres, går den
              videre til XOR-operanden
            </p>
            <p class="fragment">119 ⊕ 54 = 65</p>
            <aside class="notes">
              Tilbake til det lange tullepassordet. Vi vet nå at passordets
              lengde skal være 34 tegn langt. Da kjører programmet videre og
              gjør XOR-operasjoner med innholdet på stacken, altså tegnene i
              passordet vårt (NESTE)<br />
              Det viser seg at det er en sammenheng her: kaninen-operanden har
              alltid tallverdi "0" som gjeldende stack-verdi når det senere
              XOR-es.<br /><br />

              (NESTE x3) Her blir første tegn i chifferteksten ("w", <b>119</b>)
              XOR'et med siste tegn i tullepassordet jeg oppga ("6", <b>54</b>).
              Og svaret <b>65</b>
              puttes inn i stacken. Så krypteringsalgoritmen ligger foran oss
              her, hvis vi klarer å forstå verdiene som det XORes med
            </aside>
          </section>

          <section>
            <p>
              I <b>merkelig.py</b> hopper 🐇 alltid videre til
              feilmeldingsteksten hvis gjeldende verdi på stacken er forskjellig
              fra <b>0</b>:
            </p>
            <pre><code class="python smaller" data-trim data-noescape>
              elif op == "🐇":
              sp -= 1
              if stack[sp] != 0: # skal kaninen hoppe til ny instruks eller ikke?
                  pc += parse_num(code[pc:pc+4]) # hopp til ny instruks (feilmelding)
              else:
                  pc += 4 # programmet går videre til neste instruks
            </code></pre>
            <p class="fragment">
              Klarer vi å få gjeldende stack-verdi til å være <b>0</b> så hopper
              den videre til programmets neste instruks istedet for feilmelding
            </p>
            <aside class="notes">
              Kaninen er nøkkelen for å komme videre. Hvis den er noe annet enn
              0, så leses en ny instruks fra underfundig-programmet og
              programmet skriver ut "Ikke riktig"-feilmeldingen (NESTE)<br /><br />

              Men er gjeldende verdi på stacken når kaninen-operanden kjøres 0,
              så kjøres programmet videre. Det ønsker vi å få til!
            </aside>
          </section>

          <section>
            <p>
              Ved å analysere stacken nærmere, kan vi regne oss fram til hva som
              skal til for at 🐇 operanden får <b>0</b> som gjeldende
              stack-verdi?
            </p>
            <pre
              class="less-spacing"
            ><code class="shell smallest" data-trim data-noescape>
              🥚:(...) 53,54,(119),34 (...) # 4. Hvis z er 10, så må 119 XOR 10 = 125 = }
              🥚:(...) 53,z,(119),34 (...)
              🐰:(...) 53,z,(42),34 (...)
              🐰:(...) 53,z,42,(34) (...)
              🌱:(...) 53,z,(42),34 (...) # 3. Her må z være 10, fordi 10 + 42 må bli 52
              🌱:(...) 53,y,(42),34 (...)
              🌱:(...) 53,y,(42),34 (...)
              🐥:(...) 53,107,(y),34 (...)
              🐥:(...) 53,107,y,(34) (...)
              🐰:(...) 53,107,y,(52) (...)
              🐰:(...) 53,107,y,52,(0) (...)
              🌻:(...) 53,107,y,(52) (...) # 2. Her må y være 52, fordi 52 - 52 må bli 0
              🌻:(...) 53,107,x,(52) (...)
              🌻:(...) 53,107,x,(52) (...)
              🐇:(...) 53,107,(x),52 (...) # 1. x skal være 0
            </code></pre>
            <p class="fragment">
              119 ⊕ (52-42) = 125, dvs. ASCII-tegnet
              <span class="fragment highlight-green"><b>}</b></span> 😎
            </p>
            <aside class="notes">
              Hvordan skal vi sørge for at kaninen ikke hopper videre til
              feilmelding? På pkt. 1 nederst i stacken her må vi ha
              <b>0</b> som stack-verdi når kanin-operanden blir kjørt. Hvis vi
              regner oss bakover fra stack-verdien hos kaninen og oppover i
              stack-verdiene:<br />

              * Pkt 1. x må være 0<br />
              * Pkt 2. y må være 52 fordi her er operasjonen subtraksjon: 52
              minus 52 = 0.<br />
              * Pkt 3. z må være 10 fordi her er operasjonen addering: 10 + 42
              må bli 52<br />
              * Pkt 4. Hvis z er 10, så kan vi bruke XOR med 119 og 10 regne oss
              fram til det bakerste tegnet i det ukrypterte passordet (NESTE)<br /><br />

              119 XOR 10 = 125 (NESTE), ASCII-tallet 125 er ASCII-tegnet
              "krøllparantes".
            </aside>
          </section>

          <section>
            <h3>Algoritmen</h3>
            <p>Chiffertekst: w*4*D*T*W*J*7*A*Y*f*`*j (...)</p>
            <p class="fragment">
              w XOR (n+2 - n+1) = ?<br />
              w XOR (4-*) = ? <br />
            </p>
            <p class="fragment">
              med ASCII-tallverdier blir regnestykket:<br />
              119 XOR (52-42) = ?<br />
              119 XOR 10 = <span class="fragment highlight-green">125</span>,
              dvs. tegnet
              <span class="fragment highlight-green">}</span>
            </p>
            <aside class="notes">
              Algoritmen vi kommer fram til blir (NESTE):<br />

              * ta første tegn i chifferteksten, XOR det med tegnet 2 plasser
              bort minus tegnet 1 plass bort. Svaret i ASCII-tallverdi blir
              første dekrypterte bokstav! <br />

              * w XOR med (4 minus "asteriks") (NESTE), <br />

              * Dvs. med ASCII-tall: 119 XOR med (52 minus 42), som vil si:<br />
              * 119 XOR 10 = 125 (NESTE x2), som er tegnet høyre-krøllparentes
            </aside>
          </section>

          <section>
            <h3>Algoritmen</h3>
            <p>Chiffertekst: w*4*D*T*W*J*7*A*Y*f*`*j (...)</p>
            <p class="fragment">
              4 XOR (n+2 - n+1) = ?<br />
              4 XOR (D-*) = ? <br />
            </p>
            <p class="fragment">
              med ASCII-tallverdier blir regnestykket:<br />
              52 XOR (68-42) = ?<br />
              52 XOR 26 = <span class="fragment highlight-green">46</span>,
              alstå tegnet
              <span class="fragment highlight-green">.</span>
            </p>
            <aside class="notes">
              Vi gjentar for neste tegn i chifferteksten som er 4 (NESTE)<br />

              * 4 XOR med (D minus "asteriks") (NESTE)<br />
              * Dvs. med ASCII-tall: 52 XOR med (68 minus 42), som vil si 52 XOR
              26 = 46 (NESTE x2), som er tegnet punktum
            </aside>
          </section>

          <section>
            <p>
              Vi håndregner oss fram til vi har et par bokstaver i passordet:
            </p>
            <p class="fragment highlight-green"><b>}.nywG</b></p>
            <br />
            <h3 class="fragment fade-up">🤔</h3>
            <aside class="notes">
              Vi regner ut et par tegn til og får: (NESTE)<br />

              * krøllparentes <br />
              * punktum <br />
              * nywG<br /><br />

              Må innrømme at det ser litt gresk ut (NESTE), hadde håpet på noe
              som lignet på passordet nå
            </aside>
          </section>

          <section>
            <p>
              Vi utvider <b>løsning.py</b> med ny funksjon som bruker algoritmen
              vår til å dekryptere resten av chifferteksten
            </p>
            <aside class="notes">
              Vi er på sporet av noe. På tide å utvide <b>løsning.py</b> med en
              ny funksjon som bruker denne algorimen vi har funnet, og
              dekryptere resten av chifferteksten
            </aside>
          </section>

          <section>
            <p>Legger til ny funksjon for å dekryptere chifferteksten i <b>løsning.py</b>:</p>
            <pre><code class="python smaller" data-trim data-noescape>
              deciphered_cipher_raw = decipher(text) # text="Passord: "w*4*D*T*W (...)"

              print(deciphered_cipher_raw)
              </code></pre>
            og kjører skriptet:
            <pre><code class="shell" data-trim data-noescape>
              python .\løsning.py .\underfundig
              </code>
            </pre>
            <aside class="notes">
              Vi lagde oss en 'decipher'-funksjon i "løsning.py" for å hente
              ut det vi håper er dekrypterte flagget.<br />

              "dechipher"-funksjonen får chifferteksten som vi fant istad som
              input<br /><br />

              Vi kjører "løsning.py" og er håpefulle!
            </aside>
          </section>

          <section>
            <h3>}.nywG neP .nywG re nvan ttiM{TSHP</h3>
            <aside class="notes">
              Ha! Det ser faktisk veldig lovende ut! Men hva må vi gjøre her?<br /><br />

              Du ser at flaggformatet her ikke er helt riktig. <br />
              Stemmer, den er bakvendt! For å få riktig flaggformat så må
              reversere teksten
            </aside>
          </section>

          <section>
            <p>Vi snur om på rekkefølgen på teksten. Legger til et par linjer til i <b>løsning.py</b>:
            </p>
            <pre><code class="python smaller" data-trim data-noescape>
              deciphered_cipher = deciphered_cipher_raw[::-1]

              print(deciphered_cipher)
              </code></pre>
              og kjører skriptet igjen:
            <pre><code class="shell" data-trim data-noescape>
              python .\løsning.py .\underfundig
              </code>
            <aside class="notes">
              Vi justerer "løsning.py" og snur om på rekkefølgen i den dekrypterte teksten<br/>
              Så kjører vi "løsning.py" igjen
            </aside>
          </section>
          <section>
            <h3>PHST{Mitt navn er Gwyn. Pen Gwyn.}</h3>
            <br/>
            <p>🎉🎉🎉</p>
            <aside class="notes">
              Yes! <b>Der</b> har vi endelig flagget! <br /><br />

              Mitt navn er Gwyn. Pen Gwyn
            </aside>
          </section>

          <section data-source="leo_reversing">
            <img
              data-src="img/leo_reversing.JPG"
              class="plain"
              style="width: 60%"
            />
            <aside class="notes">
              Vi er i mål! Jeg syns vi kan være litt stolte av å ha dekompilert
              et emoji-program som kjørte på en stack-basert virtuell maskin! Jeg feiret ved å lage meg en meme jeg.
              <br /><br />

              Det var mye detektivarbeid og kodeknekking som måtte til, men med
              litt pågangsmot, innsats og å bruke tid på forstå ett og ett
              delproblem og lage oss en oversikt så så fant vi riktig løsning til slutt
            </aside>
          </section>
        </section>

        <!-- =================== OPPSUMMERING =================== -->
        <section>
          <!-- <section>
            <h2>Hva har vi lært?</h2>
            <aside class="notes">
              Så med det er mitt lille hobbyprosjekt ved veis ende, alle gåtene
              er løst. <br />

              * Hvordan gjorde jeg det? <br />
              ** blindsporbokstaver til koordinater, 2 arb.dag effektivt<br />
              ** lærte meg Linux, python, verktøy, Kali Linux VM med Docker<br />
              ** nøt prosessen<br /><br />

              * Lærte å skrive ned både løsning og oppgave, til evt. senere
              bruk<br /><br />

              (ANEKDOTE)<br />
              * Hvordan hjalp CTF-erfaringene med å løse gåten?<br />
              ** Definere <b>delmål</b><br />
              ** Sikte inn på <b>en ting</b> av gangen<br />
              ** Bruke de <b>riktige verktøyene</b>
            </aside>
          </section> -->

          <!-- <section>
            <h3>Kodeknekking</h3>
            <p>lærerikt</p>
            <p>utfordrende</p>
            <p>tålmodighetsprøve</p>
            <p>dopamin-kick!</p>
            <aside class="notes">
              * er lærerikt<br />
              * er utfordrende<br />
              * er en skikkelig tålmodighetsprøve<br />
              * er et realt dopamin-kick når man løser noe!<br /><br />

              * Hvordan blir vi gode kodeknekkere? (Verktøy og kunnskap)<br /><br />
              ** Verktøyene jeg brukte har vi allerede gått igjennom<br />
              ** Når det gjelder kunnskap har jeg noen tips...
            </aside>
          </section> -->

          <section>
            <h2>Gøy, ikke sant?</h2>
            <aside class="notes">
              Jeg håper denne oppgaven vekket litt nysgjerrighet hos deg slik
              som den gjorde hos meg <br /><br />

              Syns du det du så idag så litt gøy ut?
            </aside>
          </section>

          <section>
            <h3>Bli med og prøv selv! 🕵️‍♀️🕵️‍♂️</h3>
            <a href="https://pangea.ctf.fish">pangea.ctf.fish</a>
            <aside class="notes">
              Da kan jeg fortelle deg at min gode faggruppekollega Mathias
              Rørvik har en ny splitter ny CTF ute på
              <b>pangea.ctf.fish</b>!<br /><br />

              Prøv deg på noen oppgaver og kjenn litt på mestringsfølelsen når
              du finner flaggene. Jeg håper du også blir hekta!
            </aside>
          </section>
        </section>

        <!-- =================== TAKK =================== -->
        <section data-transition="concave">
          <h2>Takk!</h2>
          <br />
          <div class="columns">
            <div class="col">
              <div
                class="qrcode"
                align="center"
                title="https://henrikwm.github.io/p-sken-tteknekking_med_emojier"
              ></div>
              <div class="half-size"><a class="qrcode-link"></a></div>
            </div>
            <div class="col">
              <img
                src="img/oppsummering-takk2.png"
                class="plain"
                style="width: 50%"
              />
            </div>
          </div>
          <br />
          <p>
            <a href="mailto:henrik.walker.moe@bekk.no"
              >henrik.walker.moe@bekk.no</a
            >
          </p>

          <aside class="notes">
            * Alt du så idag av oppgaven og løsning finner du på min GitHub<br />
            * Tusen takk for at du så på!<br /><br />

            * Takk for meg!
          </aside>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>

    <!-- Reveal-listeners -->
    <script type="text/javascript" async defer>
      // Sources
      var sources = {
        background_image: "Foto: iStock.com, rami_hakala",
        bitmoji: "Bitmoji Avatar Ⓒ Snap Group Limited",
        henrikwm: "Kilde: Henrik Walker Moe, Lisens: CC BY 4.0",
        leo_reversing: "Kilde: https://imgflip.com/i/4edng0",
        stack_machine: "Kilde: https://en.wikipedia.org/wiki/Stack_machine",
      };

      function setFooterSource() {
        var currentSlide = Reveal.getCurrentSlide();

        var footer = document.getElementById("title-footer");
        if (footer) {
          footer.parentNode.removeChild(footer);
        }

        var source = currentSlide.getAttribute("data-source");
        if (source !== null) {
          title_footer.initialize(sources[source]);
        }
      }

      Reveal.addEventListener("ready", function (event) {
        setFooterSource();
      });

      Reveal.addEventListener(
        "slidechanged",
        function () {
          setFooterSource();
        },
        false
      );
    </script>

    <!-- QR Codes -->
    <script type="text/javascript">
      // Get presentation URL
      var qrcode_url = "https://henrikwm.github.io/p-sken-tteknekking_med_emojier";

      // Generate QR Codes : class="qrcode"
      var qrcode_elements = document.getElementsByClassName("qrcode");
      for (var i = 0; i < qrcode_elements.length; i++) {
        var qrcode_el = qrcode_elements[i];

        var qrcode = new QRCode(qrcode_el, {
          text: qrcode_url,
          width: 250,
          height: 250,
        });

        // Alter generated image
        var img_el = qrcode._el.childNodes[1];
        img_el.classList.add("plain"); // remove border
      }

      // Add text to links : class="qrcode-link"
      var qrcode_link_elements = document.getElementsByClassName("qrcode-link");
      for (var i = 0; i < qrcode_link_elements.length; i++) {
        var link_el = qrcode_link_elements[i];
        link_el.textContent = qrcode_url;
        link_el.href = qrcode_url;
      }
    </script>

    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        controls: true,
        progress: true,
        center: true,
        hash: true,
        history: true,

        navigationMode: "linear",

        transition: "slide", // none/fade/slide/convex/concave/zoom

        parallaxBackgroundImage: "img/background_bond.png",
        parallaxBackgroundSize: "3700px 1600px",

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
        dependencies: [
          {
            src: "plugin/markdown/markdown.js",
            condition: function () {
              return !!document.querySelector("[data-markdown]");
            },
          },

          // Syntax highlight for <code> elements
          { src: "plugin/highlight/highlight.js", async: true },

          { src: "plugin/search/search.js", async: true },

          // Speaker notes
          { src: "plugin/notes/notes.js", async: true },

          // Zoom in and out with Alt+click
          { src: "plugin/zoom-js/zoom.js", async: true },

          // Title-Footer plugin
          { src: "plugin/title-footer/title-footer.js" },
        ],
      });
    </script>
  </body>
</html>
